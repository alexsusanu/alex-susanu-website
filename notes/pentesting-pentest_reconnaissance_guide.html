<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Testing - Reconnaissance & Enumeration Guide - Alex Susanu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }
        
        .header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .back-nav {
            background: #f8f9ff;
            padding: 15px 30px;
            border-bottom: 2px solid #e8f0ff;
        }
        
        .back-btn {
            background: #4a90e2;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: #357abd;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .note-meta {
            color: #666;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e8f0ff;
        }
        
        .note-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 30px;
        }
        
        .tag {
            background: #e8f0ff;
            color: #4a90e2;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .note-content h2 {
            color: #4a90e2;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e8f0ff;
            padding-bottom: 8px;
        }
        
        .note-content h3 {
            color: #4a90e2;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        
        .note-content h4 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .note-content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .note-content ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .note-content li {
            margin-bottom: 8px;
        }
        
        .note-content pre {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #4a90e2;
        }
        
        .note-content code {
            background: #f8f9ff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .note-content pre code {
            background: none;
            padding: 0;
        }
        
        .footer {
            background: #f8f9ff;
            padding: 20px 30px;
            text-align: center;
            color: #666;
            border-top: 2px solid #e8f0ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Penetration Testing - Reconnaissance & Enumeration Guide</h1>
        </div>
        
        <div class="back-nav">
            <a href="../index.html" class="back-btn">← Back to Knowledge Base</a>
        </div>
        
        <div class="content">
            <div class="note-meta">
                General (pentesting) • Updated May 29, 2025
            </div>
            
            <div class="note-tags">
                
            </div>
            
            <div class="note-content">
                <h2>Penetration Testing - Reconnaissance & Enumeration Guide</h2>
<strong>Category:</strong> Penetration Testing - Phase 1  
<strong>Tags:</strong> oscp, htb, reconnaissance, enumeration, nmap, discovery, information-gathering
<h3>Reconnaissance & Enumeration Methodology</h3>
<strong>What this phase covers:</strong> Systematic information gathering and service enumeration to identify attack surface, running services, potential vulnerabilities, and entry points into target systems.
<strong>Why reconnaissance is critical:</strong> "The more you know about your target, the more likely you are to find a way in." Poor enumeration is the #1 reason penetration tests fail. 80% of successful attacks come from thorough reconnaissance.
<strong>OSCP/HTB Methodology:</strong> Follow a systematic approach - Network Discovery → Port Scanning → Service Enumeration → Vulnerability Identification → Attack Vector Planning.
<h3>Network Discovery & Host Identification</h3>
<h4><strong>nmap</strong> - The Swiss Army Knife of Network Scanning</h4>
<strong>What it does:</strong> Network scanner that discovers live hosts, open ports, running services, operating system details, and potential vulnerabilities. The foundation tool for any penetration test.
<strong>Why nmap is essential:</strong> Provides the roadmap for your entire penetration test. Identifies what services are running, their versions, and potential attack vectors. Without proper nmap enumeration, you'll miss critical services and vulnerabilities.
<strong>When to use nmap:</strong> First tool in any penetration test, continuous enumeration throughout engagement, confirming firewall rules, validating exploits worked.
<pre><code><h2>Phase 1: Network Discovery (Find live hosts)</h2>
nmap -sn 192.168.1.0/24                     # Ping sweep - ICMP echo requests
nmap -sn -PE -PP -PM 192.168.1.0/24         # Multiple ping types (ICMP echo, timestamp, netmask)
nmap -sn -PS80,443,22 192.168.1.0/24        # TCP SYN ping to common ports
nmap -sn -PA80,443,22 192.168.1.0/24        # TCP ACK ping (bypass firewalls)
nmap -sn -PU53,161,137 192.168.1.0/24       # UDP ping to DNS, SNMP, NetBIOS
<h2>Why use different ping types:</h2>
<h2>- ICMP might be blocked by firewalls</h2>
<h2>- SYN ping works when ICMP is blocked</h2>
<h2>- ACK ping bypasses stateless firewalls</h2>
<h2>- UDP ping finds hosts that only respond to UDP</h2>
<h2>Phase 2: Port Discovery (Find open services)</h2>
nmap -sS target.com                          # SYN scan (stealth, doesn't complete handshake)
nmap -sT target.com                          # TCP connect scan (completes handshake, more reliable)
nmap -sU target.com                          # UDP scan (finds DNS, SNMP, DHCP services)
nmap -sA target.com                          # ACK scan (firewall rule mapping)
nmap -sW target.com                          # Window scan (advanced OS fingerprinting)
<h2>Why different scan types matter:</h2>
<h2>- SYN scan is stealthy (doesn't appear in connection logs)</h2>
<h2>- TCP connect scan is reliable (works through proxies)</h2>
<h2>- UDP scan finds critical services often missed</h2>
<h2>- ACK scan maps firewall rules and filtered ports</h2>
<h2>- Window scan provides detailed OS fingerprinting</h2>
<h2>Phase 3: Comprehensive Port Scanning</h2>
nmap -p- target.com                          # All 65535 ports (thorough but slow)
nmap --top-ports 1000 target.com            # Most common 1000 ports (balanced)
nmap -p1-100,443,993,995 target.com         # Custom port ranges
nmap -F target.com                           # Fast scan (top 100 ports)
<h2>Port range strategies:</h2>
<h2>- Full port scan for critical targets (takes hours)</h2>
<h2>- Top ports for quick assessment (minutes)</h2>
<h2>- Custom ranges for specific services</h2>
<h2>- Fast scan for initial triage</h2>
<h2>Phase 4: Service and Version Detection</h2>
nmap -sV target.com                          # Version detection (service banners)
nmap -sV --version-intensity 5 target.com   # Aggressive version detection
nmap -sV --version-light target.com         # Light version detection (faster)
nmap -A target.com                           # Aggressive scan (-sV -sC -O)
<h2>Why version detection is crucial:</h2>
<h2>- Specific service versions have known vulnerabilities</h2>
<h2>- Banner information reveals configuration details</h2>
<h2>- Helps identify default credentials</h2>
<h2>- Required for accurate exploit selection</h2>
<h2>Phase 5: Operating System Detection</h2>
nmap -O target.com                           # OS fingerprinting
nmap -O --osscan-guess target.com            # Aggressive OS guessing
nmap --script smb-os-discovery target.com    # SMB-based OS detection
<h2>OS detection importance:</h2>
<h2>- Different exploits work on different OS versions</h2>
<h2>- Helps plan privilege escalation strategies</h2>
<h2>- Identifies patch levels and security posture</h2>
<h2>- Required for payload selection</h2>
<h2>Phase 6: Script Scanning (NSE - Nmap Scripting Engine)</h2>
nmap -sC target.com                          # Default scripts (safe, informative)
nmap --script vuln target.com                # Vulnerability detection scripts
nmap --script "safe or intrusive" target.com # Script categories
nmap --script "not dos" target.com           # All scripts except DoS
<h2>Essential NSE script categories:</h2>
nmap --script auth target.com                # Authentication bypass scripts
nmap --script brute target.com               # Brute force scripts
nmap --script discovery target.com           # Information disclosure scripts
nmap --script exploit target.com             # Exploitation scripts
nmap --script fuzzer target.com              # Fuzzing scripts
nmap --script malware target.com             # Malware detection scripts
<h2>Why NSE scripts are powerful:</h2>
<h2>- Automate common enumeration tasks</h2>
<h2>- Test for specific vulnerabilities</h2>
<h2>- Extract detailed service information</h2>
<h2>- Consistent methodology across engagements</h2></code></pre>
<strong>Advanced nmap Techniques:</strong>
<pre><code><h2>Stealth and Evasion Techniques</h2>
nmap -sS -T1 -f target.com                  # Slow timing, fragmented packets
nmap -D 192.168.1.5,192.168.1.6,ME target.com  # Decoy scanning
nmap --source-port 53 target.com            # Spoof source port (DNS)
nmap --data-length 25 target.com            # Add random data to packets
nmap -g 80 target.com                       # Spoof source port 80
<h2>Why use evasion:</h2>
<h2>- Bypass IDS/IPS detection</h2>
<h2>- Appear as legitimate traffic</h2>
<h2>- Blend with normal network activity</h2>
<h2>- Avoid rate limiting and blocking</h2>
<h2>Timing and Performance Optimization</h2>
nmap -T0 target.com                          # Paranoid timing (very slow)
nmap -T1 target.com                          # Sneaky timing (slow)
nmap -T2 target.com                          # Polite timing (normal)
nmap -T3 target.com                          # Normal timing (default)
nmap -T4 target.com                          # Aggressive timing (fast)
nmap -T5 target.com                          # Insane timing (very fast)
<h2>Custom timing control:</h2>
nmap --min-rate 1000 target.com             # Minimum packet rate
nmap --max-rate 5000 target.com             # Maximum packet rate
nmap --max-retries 3 target.com             # Retry failed probes
nmap --host-timeout 300s target.com         # Per-host timeout
<h2>Output and Reporting</h2>
nmap -oN scan.txt target.com                # Normal output format
nmap -oX scan.xml target.com                # XML output format
nmap -oG scan.gnmap target.com              # Greppable output format
nmap -oA scan target.com                    # All output formats
nmap --open target.com                      # Show only open ports
<h2>Why different output formats:</h2>
<h2>- Normal for human reading</h2>
<h2>- XML for tool integration</h2>
<h2>- Greppable for bash processing</h2>
<h2>- All formats for comprehensive reporting</h2></code></pre>
<strong>Real-world nmap Scenarios:</strong>
<pre><code><h2>Scenario 1: Initial Network Assessment</h2>
<h2>Goal: Map entire network and identify all services</h2>
nmap -sn 10.10.10.0/24 | grep -E "Nmap scan report" | awk '{print $5}' > live_hosts.txt
for host in $(cat live_hosts.txt); do
    nmap -sS -sV -O -oA "scan_$host" "$host" &
done
wait  # Wait for all background scans to complete
<h2>Why this approach:</h2>
<h2>- Parallel scanning saves time</h2>
<h2>- Comprehensive coverage of network</h2>
<h2>- Separate files for each host</h2>
<h2>- Systematic documentation</h2>
<h2>Scenario 2: Web Application Discovery</h2>
nmap -p80,443,8080,8443,8000,8888 --script http-enum,http-title,http-headers target.com
<h2>Discovers web applications and basic information</h2>
<h2>http-enum finds common directories</h2>
<h2>http-title reveals application names</h2>
<h2>http-headers shows server information</h2>
<h2>Scenario 3: Database Service Enumeration</h2>
nmap -p1433,3306,5432,1521,27017 --script "<em>sql</em>" target.com
<h2>Targets common database ports</h2>
<h2>SQL-related scripts test for vulnerabilities</h2>
<h2>Identifies database types and versions</h2>
<h2>Scenario 4: Active Directory Environment</h2>
nmap -p88,135,139,389,445,636,3268,3269 --script smb-enum-*,ldap-rootdse target.com
<h2>Targets AD-related ports (Kerberos, SMB, LDAP)</h2>
<h2>SMB enumeration scripts gather domain information</h2>
<h2>LDAP scripts reveal directory structure</h2>
<h2>Scenario 5: Vulnerability Assessment Focus</h2>
nmap --script "vuln and not dos" --script-args=unsafe=1 target.com
<h2>Runs all vulnerability scripts except DoS</h2>
<h2>unsafe=1 enables potentially harmful checks</h2>
<h2>Comprehensive vulnerability detection</h2></code></pre>
<h4><strong>masscan</strong> - High-Speed Port Scanner</h4>
<strong>What it does:</strong> Extremely fast port scanner capable of scanning the entire internet in under 5 minutes. Uses asynchronous transmission for maximum speed.
<strong>Why use masscan:</strong> When you need to scan large networks quickly or when nmap is too slow. Perfect for initial reconnaissance of large IP ranges.
<strong>When to use masscan:</strong> Large network assessments, internet-wide scanning, when speed is more important than stealth, initial port discovery before detailed nmap scanning.
<pre><code><h2>Basic masscan usage</h2>
masscan -p1-65535 192.168.1.0/24 --rate=1000
<h2>Scans all ports on /24 network at 1000 packets/second</h2>
<h2>Much faster than nmap for large ranges</h2>
<h2>Targeted service discovery</h2>
masscan -p80,443,22,21,25,53,110,143,993,995 10.10.0.0/16 --rate=10000
<h2>Scans common ports across large network</h2>
<h2>High rate for maximum speed</h2>
<h2>Output formatting</h2>
masscan -p1-1000 192.168.1.0/24 --rate=1000 -oG masscan.gnmap
masscan -p1-1000 192.168.1.0/24 --rate=1000 -oX masscan.xml
masscan -p1-1000 192.168.1.0/24 --rate=1000 -oJ masscan.json
<h2>Why different formats:</h2>
<h2>- Greppable for bash processing</h2>
<h2>- XML for tool integration</h2>
<h2>- JSON for modern applications</h2>
<h2>Advanced masscan techniques</h2>
masscan --top-ports 100 0.0.0.0/0 --rate=100000 --excludefile exclude.txt
<h2>Scans top 100 ports on entire internet</h2>
<h2>Excludes addresses from file</h2>
<h2>Maximum practical scanning rate</h2>
<h2>Integration with nmap</h2>
masscan -p1-65535 192.168.1.0/24 --rate=1000 | grep "open" | awk '{print $4,$3}' | sort -n > open_ports.txt
<h2>Use masscan for port discovery</h2>
<h2>Process results for nmap input</h2>
<h2>Follow up with detailed nmap scanning</h2>
<h2>Why this workflow is effective:</h2>
<h2>- Masscan quickly identifies open ports</h2>
<h2>- Nmap provides detailed service information</h2>
<h2>- Best of both tools' strengths</h2></code></pre>
<h4><strong>rustscan</strong> - Modern Port Scanner</h4>
<strong>What it does:</strong> Modern port scanner written in Rust that combines speed with nmap integration. Automatically runs nmap scripts on discovered ports.
<strong>Why rustscan is useful:</strong> Bridges the gap between masscan's speed and nmap's functionality. Automatically follows up port discovery with detailed enumeration.
<pre><code><h2>Basic rustscan with nmap integration</h2>
rustscan -a 192.168.1.10 -- -sC -sV
<h2>Discovers open ports quickly</h2>
<h2>Automatically runs nmap scripts on found ports</h2>
<h2>Combines speed with detailed enumeration</h2>
<h2>Batch scanning multiple hosts</h2>
rustscan -a 192.168.1.10,192.168.1.11,192.168.1.12 -- -A
<h2>Scans multiple hosts efficiently</h2>
<h2>Runs aggressive nmap scan on results</h2>
<h2>Custom port ranges and timing</h2>
rustscan -a 192.168.1.10 -p 1-10000 --ulimit 5000 -- -sV
<h2>Custom port range</h2>
<h2>Adjusted ulimit for performance</h2>
<h2>Version detection on found ports</h2></code></pre>
<h3>Service-Specific Enumeration</h3>
<h4><strong>HTTP/HTTPS Web Service Enumeration</strong></h4>
<strong>Why web enumeration is critical:</strong> Web applications are the most common attack vector in modern penetration tests. Hidden directories, files, and functionality often contain vulnerabilities or sensitive information.
<p>#### <strong>gobuster</strong> - Directory and File Brute-forcing</p>
<strong>What it does:</strong> Fast directory/file brute-forcer written in Go. Uses wordlists to discover hidden web content through systematic enumeration.
<strong>Why gobuster over alternatives:</strong> Faster than dirb/dirbuster, supports multiple protocols, active development, handles large wordlists efficiently.
<pre><code><h2>Basic directory brute-forcing</h2>
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt
<h2>Uses common directory names</h2>
<h2>Discovers hidden admin panels, backup directories</h2>
<h2>Advanced directory enumeration</h2>
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/big.txt -x php,html,txt,bak,old,zip
<h2>Larger wordlist for thorough coverage</h2>
<h2>Multiple file extensions to find various content types</h2>
<h2>Discovers backup files, configuration files, archives</h2>
<h2>Why file extensions matter:</h2>
<h2>- .php files may contain source code or configs</h2>
<h2>- .bak files often contain backup versions with vulnerabilities</h2>
<h2>- .txt files may contain sensitive information</h2>
<h2>- .zip files may contain source code or backups</h2>
<h2>Status code filtering and customization</h2>
gobuster dir -u http://target.com -w wordlist.txt -s 200,301,302,403
<h2>Only show specific status codes</h2>
<h2>200: Found, 301/302: Redirects (may indicate protected areas)</h2>
<h2>403: Forbidden (exists but access denied)</h2>
<p>gobuster dir -u http://target.com -w wordlist.txt -b 404,400
<h2>Hide specific status codes</h2>
<h2>Reduces noise from not found responses</h2></p>
<h2>Authentication and headers</h2>
gobuster dir -u http://target.com -w wordlist.txt -H "Authorization: Bearer token123"
<h2>Include authentication headers</h2>
<h2>Access authenticated areas of application</h2>
<p>gobuster dir -u http://target.com -w wordlist.txt -c "session=abc123"
<h2>Include session cookies</h2>
<h2>Maintain authenticated session during enumeration</h2></p>
<h2>Recursive directory scanning</h2>
gobuster dir -u http://target.com -w wordlist.txt -r
<h2>Follow redirects automatically</h2>
<h2>Discover deeper directory structures</h2>
<h2>Advanced filtering and output</h2>
gobuster dir -u http://target.com -w wordlist.txt -l -k -t 50
<h2>-l: Include response length (helps identify interesting responses)</h2>
<h2>-k: Skip SSL certificate verification</h2>
<h2>-t 50: Use 50 threads for faster scanning</h2>
<h2>Virtual host enumeration</h2>
gobuster vhost -u target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt
<h2>Discovers virtual hosts and subdomains</h2>
<h2>Finds applications hosted on same IP</h2>
<h2>May reveal development or staging environments</h2>
<h2>Why vhost enumeration is important:</h2>
<h2>- Different virtual hosts may have different security</h2>
<h2>- Development sites often have weaker security</h2>
<h2>- May reveal internal network information</h2></code></pre>
<p>#### <strong>ffuf</strong> - Fast Web Fuzzer</p>
<strong>What it does:</strong> Fast web fuzzer that can fuzz directories, files, parameters, headers, and more. More flexible than gobuster for complex fuzzing scenarios.
<strong>Why ffuf is powerful:</strong> Supports fuzzing multiple positions simultaneously, advanced filtering options, and can fuzz any part of HTTP requests.
<pre><code><h2>Directory fuzzing (similar to gobuster)</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://target.com/FUZZ
<h2>FUZZ keyword is replaced with wordlist entries</h2>
<h2>Discovers hidden directories and files</h2>
<h2>File extension fuzzing</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://target.com/FUZZ -e .php,.html,.txt,.bak
<h2>Automatically appends extensions</h2>
<h2>Finds files with different extensions</h2>
<h2>Parameter fuzzing (GET parameters)</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://target.com/search.php?FUZZ=test
<h2>Fuzzes GET parameter names</h2>
<h2>Discovers hidden parameters that may be vulnerable</h2>
<h2>POST parameter fuzzing</h2>
ffuf -w params.txt -X POST -d "FUZZ=test" -u http://target.com/login.php
<h2>Fuzzes POST parameter names</h2>
<h2>Tests for hidden form parameters</h2>
<h2>Header fuzzing</h2>
ffuf -w headers.txt -H "FUZZ: test" -u http://target.com/
<h2>Fuzzes HTTP headers</h2>
<h2>Tests for header-based vulnerabilities</h2>
<h2>Advanced filtering</h2>
ffuf -w wordlist.txt -u http://target.com/FUZZ -fs 4242
<h2>Filter out responses with specific size</h2>
<h2>Reduces noise from error pages</h2>
<p>ffuf -w wordlist.txt -u http://target.com/FUZZ -fc 404,403
<h2>Filter out specific status codes</h2>
<h2>Focus on interesting responses</h2></p>
<p>ffuf -w wordlist.txt -u http://target.com/FUZZ -fr "Not Found"
<h2>Filter out responses containing specific text</h2>
<h2>Customize filtering for target application</h2></p>
<h2>Multi-position fuzzing</h2>
ffuf -w users.txt:USER -w passwords.txt:PASS -X POST -d "username=USER&password=PASS" -u http://target.com/login
<h2>Fuzz multiple positions simultaneously</h2>
<h2>Useful for credential brute-forcing</h2>
<h2>Subdomain enumeration</h2>
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://FUZZ.target.com/
<h2>Virtual host fuzzing</h2>
<h2>Discovers subdomains and applications</h2></code></pre>
<p>#### <strong>nikto</strong> - Web Vulnerability Scanner</p>
<strong>What it does:</strong> Web vulnerability scanner that tests for over 6700 potentially dangerous files/programs, outdated versions, and security issues.
<strong>Why nikto is valuable:</strong> Automated vulnerability detection, comprehensive database of known issues, good for initial web application assessment.
<pre><code><h2>Basic vulnerability scan</h2>
nikto -h http://target.com
<h2>Comprehensive vulnerability assessment</h2>
<h2>Tests for common web application issues</h2>
<h2>Advanced scanning options</h2>
nikto -h http://target.com -p 80,443,8080 -Format htm -output nikto_results.html
<h2>Multiple ports</h2>
<h2>HTML output format for reporting</h2>
<h2>Authentication scanning</h2>
nikto -h http://target.com -id admin:password
<h2>Scan authenticated areas</h2>
<h2>May reveal additional vulnerabilities</h2>
<h2>Tuning and customization</h2>
nikto -h http://target.com -T 1,2,3,4,5,6,7,8,9,0
<h2>Specific test categories:</h2>
<h2>1: Interesting files, 2: Misconfiguration</h2>
<h2>3: Information disclosure, 4: Injection</h2>
<h2>5: Remote file retrieval, 6: Denial of service</h2>
<h2>7: Remote file retrieval, 8: Command execution</h2>
<h2>9: SQL injection, 0: File upload</h2>
<h2>Integration with other tools</h2>
nikto -h http://target.com -output nikto.xml -Format xml
<h2>XML output for tool integration</h2>
<h2>Can be imported into vulnerability management systems</h2></code></pre>
<h4><strong>SMB/NetBIOS Enumeration</strong></h4>
<strong>Why SMB enumeration is critical:</strong> SMB shares often contain sensitive files, and SMB services have many historical vulnerabilities. Common in Windows environments and often misconfigured.
<p>#### <strong>smbclient</strong> - SMB Share Access</p>
<strong>What it does:</strong> Command-line SMB client that can list shares, access files, and interact with SMB services.
<pre><code><h2>List SMB shares</h2>
smbclient -L //target.com -N
<h2>-L lists shares, -N uses null authentication</h2>
<h2>Discovers available shares without credentials</h2>
<h2>Access SMB shares</h2>
smbclient //target.com/sharename -N
<h2>Access specific share anonymously</h2>
<h2>Navigate and download files</h2>
<h2>Authenticated access</h2>
smbclient //target.com/C$ -U username%password
<h2>Access with credentials</h2>
<h2>C$ is admin share (full system access)</h2>
<h2>Download files recursively</h2>
smbclient //target.com/share -N -c "recurse ON; prompt OFF; mget *"
<h2>Download entire share contents</h2>
<h2>Useful for offline analysis</h2></code></pre>
<p>#### <strong>enum4linux</strong> - SMB/LDAP Enumeration</p>
<strong>What it does:</strong> Comprehensive SMB and LDAP enumeration tool that gathers detailed information about Windows systems.
<pre><code><h2>Comprehensive SMB enumeration</h2>
enum4linux -a target.com
<h2>All enumeration options</h2>
<h2>Users, groups, shares, policies, etc.</h2>
<h2>Specific enumeration types</h2>
enum4linux -U target.com                    # User enumeration
enum4linux -G target.com                    # Group enumeration
enum4linux -S target.com                    # Share enumeration
enum4linux -P target.com                    # Password policy enumeration
<h2>Why each enumeration type matters:</h2>
<h2>- Users: Potential targets for attacks</h2>
<h2>- Groups: Understanding privilege structure</h2>
<h2>- Shares: File access and sensitive data</h2>
<h2>- Policies: Account lockout and password rules</h2></code></pre>
<h4><strong>DNS Enumeration</strong></h4>
<strong>Why DNS enumeration matters:</strong> DNS reveals network topology, subdomains, internal systems, and may allow zone transfers that expose entire network structure.
<p>#### <strong>dnsrecon</strong> - DNS Reconnaissance</p>
<strong>What it does:</strong> Comprehensive DNS enumeration tool that performs various DNS reconnaissance techniques.
<pre><code><h2>Basic DNS enumeration</h2>
dnsrecon -d target.com
<h2>Standard DNS record enumeration</h2>
<h2>A, AAAA, MX, NS, SOA records</h2>
<h2>Zone transfer attempt</h2>
dnsrecon -d target.com -t axfr
<h2>Attempts DNS zone transfer</h2>
<h2>May reveal entire DNS zone contents</h2>
<h2>Subdomain brute-forcing</h2>
dnsrecon -d target.com -D /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t brt
<h2>Brute-force subdomains using wordlist</h2>
<h2>Discovers additional subdomains and services</h2>
<h2>Reverse DNS lookup</h2>
dnsrecon -r 192.168.1.0/24
<h2>Reverse DNS on IP range</h2>
<h2>Discovers hostnames for IP addresses</h2></code></pre>
<p>#### <strong>dnsenum</strong> - DNS Enumeration Alternative</p>
<strong>What it does:</strong> Another comprehensive DNS enumeration tool with different capabilities and wordlists.
<pre><code><h2>Comprehensive DNS enumeration</h2>
dnsenum target.com
<h2>Automatic enumeration with built-in wordlists</h2>
<h2>Attempts zone transfers and subdomain enumeration</h2>
<h2>Custom wordlist</h2>
dnsenum --dnsserver 8.8.8.8 -f /usr/share/seclists/Discovery/DNS/fierce-hostlist.txt target.com
<h2>Use specific DNS server</h2>
<h2>Custom subdomain wordlist</h2></code></pre>
<h3>Automated Reconnaissance Frameworks</h3>
<h4><strong>AutoRecon</strong> - Automated Multi-Service Reconnaissance</h4>
<strong>What it does:</strong> Comprehensive automated reconnaissance tool that runs appropriate enumeration tools based on discovered services.
<strong>Why AutoRecon is powerful:</strong> Systematic approach, runs multiple tools simultaneously, service-specific enumeration, generates organized reports.
<pre><code><h2>Basic AutoRecon scan</h2>
autorecon target.com
<h2>Automatic service detection and enumeration</h2>
<h2>Runs appropriate tools for each discovered service</h2>
<h2>Multiple targets</h2>
autorecon target1.com target2.com 192.168.1.10
<h2>Parallel scanning of multiple targets</h2>
<h2>Efficient resource utilization</h2>
<h2>Custom port ranges</h2>
autorecon --ports="1-10000" target.com
<h2>Custom port range for initial discovery</h2>
<h2>Balances thoroughness with speed</h2>
<h2>Specific service enumeration</h2>
autorecon --only-scans-dir target.com
<h2>Only run directory/file enumeration</h2>
<h2>Focus on specific enumeration types</h2></code></pre>
<h4><strong>nmapAutomator</strong> - Automated nmap Workflows</h4>
<strong>What it does:</strong> Bash script that automates common nmap scanning workflows with different modes for different scenarios.
<pre><code><h2>Different scanning modes</h2>
./nmapAutomator.sh target.com All
<h2>Comprehensive scanning (Network, Port, Script, Full)</h2>
<p>./nmapAutomator.sh target.com Basic
<h2>Basic scanning (Network, Port)</h2></p>
<p>./nmapAutomator.sh target.com Web
<h2>Web-focused scanning (HTTP enumeration)</h2></p>
<p>./nmapAutomator.sh target.com Vulns
<h2>Vulnerability-focused scanning</h2></code></pre></p>
<h3>Manual Service Enumeration Techniques</h3>
<h4><strong>Banner Grabbing and Service Interaction</strong></h4>
<strong>Why manual enumeration matters:</strong> Automated tools miss context-specific information and may not test all functionality. Manual enumeration provides deeper understanding.
<pre><code><h2>Netcat banner grabbing</h2>
nc -nv target.com 80                         # HTTP service
nc -nv target.com 21                         # FTP service
nc -nv target.com 25                         # SMTP service
nc -nv target.com 110                        # POP3 service
<h2>Why banner grabbing is important:</h2>
<h2>- Reveals exact service versions</h2>
<h2>- May show custom error messages</h2>
<h2>- Identifies service behavior</h2>
<h2>- Helps plan specific attacks</h2>
<h2>Telnet service interaction</h2>
telnet target.com 80
GET / HTTP/1.1
Host: target.com
<h2>Manual HTTP requests reveal:</h2>
<h2>- Server headers and versions</h2>
<h2>- Supported HTTP methods</h2>
<h2>- Error page information</h2>
<h2>- Application framework details</h2>
<h2>OpenSSL for SSL/TLS services</h2>
openssl s_client -connect target.com:443
<h2>SSL/TLS service information</h2>
<h2>Certificate details and chain</h2>
<h2>Supported cipher suites</h2>
<h2>Protocol versions</h2>
<h2>SSH service enumeration</h2>
ssh -v target.com
<h2>SSH version and supported methods</h2>
<h2>Host key fingerprints</h2>
<h2>Available authentication methods</h2></code></pre>
<h3>Reconnaissance Methodology Summary</h3>
<h4><strong>Systematic Approach for HTB/OSCP:</strong></h4>
<p>1. <strong>Network Discovery</strong>
   - Use nmap ping sweep to find live hosts
   - Document all discovered systems
   - Identify network topology and subnets</p>
<p>2. <strong>Port Scanning</strong>
   - Start with top ports for quick overview
   - Follow with comprehensive port scans
   - Use different scan types for evasion</p>
<p>3. <strong>Service Enumeration</strong>
   - Version detection on all open ports
   - Service-specific enumeration tools
   - Manual interaction and banner grabbing</p>
<p>4. <strong>Vulnerability Assessment</strong>
   - Run vulnerability scanners (nmap scripts, nikto)
   - Research discovered service versions
   - Identify potential attack vectors</p>
<p>5. <strong>Documentation and Analysis</strong>
   - Organize all findings systematically
   - Prioritize services by attack potential
   - Plan exploitation phase based on findings</p>
<strong>Key Success Factors:</strong>
<ul><li><strong>Thoroughness over speed</strong> - Don't rush enumeration</li>
<li><strong>Multiple tools</strong> - Different tools find different things</li>
<li><strong>Service-specific approach</strong> - Each service needs different enumeration</li>
<li><strong>Documentation</strong> - Keep detailed notes of all findings</li>
<li><strong>Iteration</strong> - Re-enumerate after gaining access</li></ul>
<p>This reconnaissance methodology forms the foundation for successful penetration testing. Thorough enumeration directly correlates with successful exploitation in HTB challenges and OSCP exam scenarios.</p>
            </div>
        </div>
        
        <div class="footer">
            <p><a href="../index.html">← Back to Alex Susanu's Knowledge Base</a></p>
        </div>
    </div>
</body>
</html>