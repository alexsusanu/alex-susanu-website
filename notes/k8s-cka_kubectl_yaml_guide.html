<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CKA Guide: kubectl Commands & YAML Manifests - Practical Skills Mastery - Alex Susanu</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <style>
        /* Note-specific styles that extend the main CSS */
        .note-page {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .note-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }
        
        .note-header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .back-nav {
            background: #f8f9ff;
            padding: 15px 30px;
            border-bottom: 2px solid #e8f0ff;
        }
        
        .back-btn {
            background: #4a90e2;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: #357abd;
        }
        
        .note-content-wrapper {
            padding: 40px 30px;
        }
        
        .note-meta {
            color: #666;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e8f0ff;
        }
        
        .note-footer {
            background: #f8f9ff;
            padding: 20px 30px;
            text-align: center;
            color: #666;
            border-top: 2px solid #e8f0ff;
        }
    </style>
</head>
<body class="note-page">
    <div class="note-container">
        <div class="note-header">
            <h1>CKA Guide: kubectl Commands & YAML Manifests - Practical Skills Mastery</h1>
        </div>
        
        <div class="back-nav">
            <a href="../index.html" class="back-btn">← Back to Knowledge Base</a>
        </div>
        
        <div class="note-content-wrapper">
            <div class="note-meta">
                General (k8s) • Updated June 02, 2025
            </div>
            
            <div class="note-tags">
                
            </div>
            
            <div class="note-content">
                <h2>CKA Guide: kubectl Commands & YAML Manifests - Practical Skills Mastery</h2>
<h3>Fundamental Conceptual Understanding</h3>
<h4>The kubectl Philosophy</h4>
<strong>kubectl as the Universal API Client:</strong>
<pre><code>Traditional Infrastructure Management:
├── Multiple specialized tools (AWS CLI, gcloud, Azure CLI, etc.)
├── Vendor-specific commands and syntax
├── Different authentication mechanisms
├── Inconsistent output formats
└── Tool sprawl and cognitive overhead
<p>kubectl Universal Interface:
├── Single tool for all Kubernetes operations
├── Consistent command structure and patterns
├── Unified authentication and authorization
├── Standardized output formats (YAML, JSON, custom)
├── Extensible through plugins and custom resources
└── Infrastructure-agnostic abstraction layer</code></pre></p>
<strong>The Declarative vs Imperative Paradigm:</strong>
<pre><code>Imperative Commands (How to do it):
├── kubectl create deployment webapp --image=nginx
├── kubectl scale deployment webapp --replicas=3
├── kubectl expose deployment webapp --port=80
├── Direct manipulation of resources
└── Good for: Quick operations, debugging, experimentation
<p>Declarative Manifests (What you want):
├── Define desired state in YAML files
├── Apply configurations idempotently
├── Version control and GitOps workflows
├── Reproducible infrastructure
└── Good for: Production systems, automation, compliance</p>
<p>Hybrid Approach:
├── Use imperative commands for rapid prototyping
├── Generate YAML templates with --dry-run=client -o yaml
├── Convert to declarative manifests for production
└── Maintain both skills for exam and real-world scenarios</code></pre></p>
<h4>Command Structure and Patterns</h4>
<strong>kubectl Command Anatomy:</strong>
<pre><code>kubectl [command] [TYPE] [NAME] [flags]
   │        │       │      │       │
   │        │       │      │       └── Modifiers (--dry-run, -o yaml, etc.)
   │        │       │      └────────── Resource name (optional)
   │        │       └───────────────── Resource type (pod, service, etc.)
   │        └───────────────────────── Action (get, create, apply, etc.)
   └────────────────────────────────── Kubernetes CLI tool
<p>Examples:
kubectl get pods webapp-123 --namespace=production -o yaml
kubectl create deployment webapp --image=nginx --replicas=3
kubectl apply -f webapp-deployment.yaml --validate=true
kubectl delete pod webapp-123 --grace-period=30</code></pre></p>
<strong>Resource Naming Conventions:</strong>
<pre><code>Kubernetes Resource Hierarchy:
├── Cluster-scoped resources (nodes, namespaces, clusterroles)
├── Namespace-scoped resources (pods, services, deployments)
├── Resource types (singular and plural forms)
└── Resource aliases (short names for efficiency)
<p>Resource Type Examples:
Long Form              Short Form    Scope
────────────────────   ──────────    ─────────────
pods                   po            Namespaced
services               svc           Namespaced
deployments            deploy        Namespaced
replicasets            rs            Namespaced
persistentvolumes      pv            Cluster
persistentvolumeclaims pvc           Namespaced
nodes                  no            Cluster
namespaces             ns            Cluster</code></pre></p>
<h3>Essential kubectl Commands Mastery</h3>
<h4>Resource Management Commands</h4>
<strong>Core CRUD Operations:</strong>
<pre><code><h2>CREATE - Generate and create resources</h2>
kubectl create deployment webapp --image=nginx:1.21 --replicas=3
kubectl create service clusterip webapp --tcp=80:80
kubectl create secret generic db-secret --from-literal=password=secret123
kubectl create configmap app-config --from-file=config.properties
kubectl create namespace development
kubectl create serviceaccount webapp-sa
<h2>GET - Retrieve and display resources</h2>
kubectl get pods                           # List pods in current namespace
kubectl get pods --all-namespaces         # List pods in all namespaces
kubectl get pods -o wide                  # Show additional columns (IP, node)
kubectl get pods --show-labels            # Show labels
kubectl get pods -l app=webapp            # Filter by labels
kubectl get pods --field-selector=status.phase=Running
kubectl get events --sort-by=.metadata.creationTimestamp
<h2>DESCRIBE - Detailed resource information</h2>
kubectl describe pod webapp-123           # Detailed pod information
kubectl describe node worker-1            # Node details and allocated resources
kubectl describe service webapp           # Service configuration and endpoints
kubectl describe deployment webapp        # Deployment status and history
<h2>APPLY - Declarative configuration management</h2>
kubectl apply -f webapp.yaml              # Apply single file
kubectl apply -f manifests/               # Apply directory of files
kubectl apply -k overlays/production/     # Apply Kustomize configuration
kubectl apply --dry-run=server -f webapp.yaml  # Validate without applying
<h2>DELETE - Remove resources</h2>
kubectl delete pod webapp-123             # Delete specific pod
kubectl delete pods -l app=webapp         # Delete pods by label
kubectl delete deployment webapp          # Delete deployment (and its pods)
kubectl delete -f webapp.yaml             # Delete resources defined in file
kubectl delete all -l app=webapp          # Delete all resources with label</code></pre>
<strong>Advanced Resource Operations:</strong>
<pre><code><h2>EDIT - Modify resources interactively</h2>
kubectl edit deployment webapp             # Edit deployment in default editor
kubectl edit pod webapp-123               # Edit pod (limited fields)
kubectl edit service webapp               # Edit service configuration
<h2>PATCH - Programmatic resource updates</h2>
kubectl patch deployment webapp -p '{"spec":{"replicas":5}}'
kubectl patch pod webapp-123 -p '{"spec":{"activeDeadlineSeconds":30}}'
kubectl patch service webapp --type='merge' -p='{"spec":{"type":"NodePort"}}'
<h2>REPLACE - Replace entire resource</h2>
kubectl replace -f webapp-updated.yaml    # Replace with new configuration
kubectl replace --force -f webapp.yaml    # Force replacement (delete and recreate)
<h2>SCALE - Adjust replica count</h2>
kubectl scale deployment webapp --replicas=5
kubectl scale deployment webapp --current-replicas=3 --replicas=5  # Conditional
kubectl autoscale deployment webapp --min=2 --max=10 --cpu-percent=70
<h2>ROLLOUT - Manage deployment history</h2>
kubectl rollout history deployment webapp
kubectl rollout undo deployment webapp
kubectl rollout undo deployment webapp --to-revision=2
kubectl rollout status deployment webapp
kubectl rollout restart deployment webapp</code></pre>
<h4>Resource Inspection and Debugging</h4>
<strong>Information Gathering Commands:</strong>
<pre><code><h2>LOGS - Container output</h2>
kubectl logs webapp-123                   # Single container pod
kubectl logs webapp-123 -c init-container # Specific container in multi-container pod
kubectl logs webapp-123 --previous        # Previous container instance
kubectl logs webapp-123 -f                # Follow/stream logs
kubectl logs webapp-123 --since=1h        # Last hour of logs
kubectl logs webapp-123 --tail=100        # Last 100 lines
kubectl logs -l app=webapp               # Logs from all pods with label
kubectl logs deployment/webapp           # Logs from deployment pods
<h2>EXEC - Execute commands in containers</h2>
kubectl exec webapp-123 -- ls -la         # Execute single command
kubectl exec -it webapp-123 -- /bin/bash  # Interactive shell
kubectl exec webapp-123 -c sidecar -- ps aux  # Execute in specific container
<h2>PORT-FORWARD - Local access to pod/service ports</h2>
kubectl port-forward pod/webapp-123 8080:80
kubectl port-forward service/webapp 8080:80
kubectl port-forward deployment/webapp 8080:80
kubectl port-forward --address 0.0.0.0 pod/webapp-123 8080:80  # Bind to all interfaces
<h2>TOP - Resource usage</h2>
kubectl top nodes                         # Node resource usage
kubectl top pods                          # Pod resource usage
kubectl top pods --sort-by=memory        # Sort by memory usage
kubectl top pods --containers            # Per-container usage
<h2>CP - Copy files to/from containers</h2>
kubectl cp webapp-123:/app/config.json ./config.json
kubectl cp ./new-config.json webapp-123:/app/config.json
kubectl cp webapp-123:/var/log/ ./logs/ -c sidecar  # Specific container</code></pre>
<strong>Context and Configuration Management:</strong>
<pre><code><h2>CONTEXT - Cluster and namespace management</h2>
kubectl config get-contexts               # List available contexts
kubectl config current-context           # Show current context
kubectl config use-context production    # Switch context
kubectl config set-context --current --namespace=development
kubectl config set-context dev --cluster=dev-cluster --user=dev-user --namespace=dev
<h2>CLUSTER-INFO - Cluster information</h2>
kubectl cluster-info                      # Cluster endpoints
kubectl cluster-info dump                # Detailed cluster state
kubectl version                          # Client and server versions
kubectl api-versions                     # Available API versions
kubectl api-resources                    # Available resource types
<h2>AUTH - Authentication and authorization</h2>
kubectl auth can-i create pods           # Check permissions
kubectl auth can-i create pods --as=system:serviceaccount:default:webapp
kubectl auth can-i '<em>' '</em>'              # Check if cluster admin
kubectl auth can-i create pods --list    # List allowed actions</code></pre>
<h4>Powerful Filtering and Output Options</h4>
<strong>Label and Field Selectors:</strong>
<pre><code><h2>LABEL SELECTORS - Filter by labels</h2>
kubectl get pods -l app=webapp                    # Equality
kubectl get pods -l app!=webapp                   # Inequality  
kubectl get pods -l 'app in (webapp,api)'         # Set inclusion
kubectl get pods -l 'app notin (webapp,api)'      # Set exclusion
kubectl get pods -l app=webapp,version=v1         # Multiple labels (AND)
kubectl get pods -l 'app=webapp,version!=v2'      # Mixed conditions
<h2>FIELD SELECTORS - Filter by object fields</h2>
kubectl get pods --field-selector=status.phase=Running
kubectl get pods --field-selector=status.phase!=Pending
kubectl get pods --field-selector=spec.nodeName=worker-1
kubectl get events --field-selector=type=Warning
kubectl get pods --field-selector=metadata.namespace=default
<h2>COMBINING SELECTORS</h2>
kubectl get pods -l app=webapp --field-selector=status.phase=Running</code></pre>
<strong>Output Formatting Mastery:</strong>
<pre><code><h2>JSON OUTPUT - Structured data</h2>
kubectl get pod webapp-123 -o json
kubectl get pods -o json | jq '.items[].metadata.name'
kubectl get pods -o json | jq '.items[] | select(.status.phase=="Running")'
<h2>YAML OUTPUT - Human-readable structured data</h2>
kubectl get pod webapp-123 -o yaml
kubectl get deployment webapp -o yaml > webapp-backup.yaml
<h2>CUSTOM COLUMNS - Tailored output</h2>
kubectl get pods -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,IP:.status.podIP
kubectl get nodes -o custom-columns=NAME:.metadata.name,CPU:.status.capacity.cpu,MEMORY:.status.capacity.memory
<h2>JSONPATH - Extract specific fields</h2>
kubectl get pods -o jsonpath='{.items[*].metadata.name}'
kubectl get pods -o jsonpath='{.items[*].status.podIP}'
kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\n"}{end}'
<h2>GO TEMPLATE - Advanced formatting</h2>
kubectl get pods -o go-template='{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'
kubectl get pods -o go-template-file=pod-template.tmpl
<h2>WIDE OUTPUT - Additional columns</h2>
kubectl get pods -o wide                  # Shows IP, node, nominated node, readiness gates
kubectl get services -o wide              # Shows endpoints, age
kubectl get nodes -o wide                 # Shows OS, kernel version, container runtime</code></pre>
<h4>Resource Generation and Templating</h4>
<strong>Dry-run for YAML Generation:</strong>
<pre><code><h2>DEPLOYMENT generation</h2>
kubectl create deployment webapp --image=nginx:1.21 --replicas=3 --dry-run=client -o yaml
<h2>SERVICE generation</h2>
kubectl create service clusterip webapp --tcp=80:80 --dry-run=client -o yaml
kubectl create service nodeport webapp --tcp=80:80 --node-port=30080 --dry-run=client -o yaml
kubectl create service loadbalancer webapp --tcp=80:80 --dry-run=client -o yaml
<h2>CONFIGMAP generation</h2>
kubectl create configmap app-config --from-literal=key1=value1 --from-literal=key2=value2 --dry-run=client -o yaml
kubectl create configmap app-config --from-file=config.properties --dry-run=client -o yaml
<h2>SECRET generation</h2>
kubectl create secret generic db-secret --from-literal=username=admin --from-literal=password=secret --dry-run=client -o yaml
kubectl create secret docker-registry registry-secret --docker-server=registry.com --docker-username=user --docker-password=pass --dry-run=client -o yaml
<h2>JOB generation</h2>
kubectl create job backup --image=backup:latest --dry-run=client -o yaml
<h2>CRONJOB generation</h2>
kubectl create cronjob backup --image=backup:latest --schedule="0 2 <em> </em> *" --dry-run=client -o yaml</code></pre>
<strong>Quick Resource Creation Patterns:</strong>
<pre><code><h2>POD creation (exam shortcut)</h2>
kubectl run webapp --image=nginx:1.21 --dry-run=client -o yaml > webapp-pod.yaml
kubectl run webapp --image=nginx:1.21 --labels=app=webapp,version=v1
kubectl run webapp --image=nginx:1.21 --env=APP_ENV=production
kubectl run webapp --image=nginx:1.21 --requests=cpu=100m,memory=128Mi
kubectl run webapp --image=nginx:1.21 --limits=cpu=500m,memory=512Mi
kubectl run webapp --image=nginx:1.21 --restart=Never  # Creates Pod, not Deployment
<h2>TEMPORARY pods for debugging</h2>
kubectl run debug --image=busybox --rm -it -- /bin/sh
kubectl run netshoot --image=nicolaka/netshoot --rm -it -- bash
kubectl run ubuntu --image=ubuntu --rm -it -- bash
<h2>EXPOSE shortcut</h2>
kubectl expose pod webapp --port=80 --target-port=80 --name=webapp-service
kubectl expose deployment webapp --port=80 --type=NodePort
kubectl expose deployment webapp --port=80 --type=LoadBalancer</code></pre>
<h3>YAML Manifests Deep Dive</h3>
<h4>YAML Structure and Best Practices</h4>
<strong>Kubernetes YAML Anatomy:</strong>
<pre><code><h2>Standard Kubernetes resource structure</h2>
apiVersion: apps/v1              # API version for the resource type
kind: Deployment                 # Resource type
metadata:                        # Resource metadata
  name: webapp                   # Resource name (DNS-1123 compliant)
  namespace: production          # Namespace (optional, defaults to 'default')
  labels:                        # Labels for organization and selection
    app: webapp
    version: v1.0.0
    environment: production
    owner: platform-team
  annotations:                   # Annotations for additional metadata
    description: "Main web application"
    maintainer: "platform-team@company.com"
    deployment.kubernetes.io/revision: "1"
spec:                           # Resource specification (desired state)
  # ... resource-specific configuration
status:                         # Resource status (actual state) - managed by Kubernetes
  # ... current resource state (read-only)</code></pre>
<strong>YAML Best Practices:</strong>
<pre><code><h2>1. Use consistent indentation (2 spaces)</h2>
<h2>2. Quote strings that could be interpreted as numbers/booleans</h2>
<h2>3. Use meaningful names and labels</h2>
<h2>4. Include resource limits and requests</h2>
<h2>5. Add documentation through annotations</h2>
<p>apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-deployment          # Descriptive name
  namespace: production
  labels:
    app: webapp                    # Application identifier
    component: frontend            # Component role
    version: "1.2.3"              # Version (quoted to prevent interpretation)
    environment: production        # Environment designation
  annotations:
    description: "Frontend web application serving user traffic"
    contact: "frontend-team@company.com"
    documentation: "https://wiki.company.com/webapp"
spec:
  replicas: 3                      # Explicit replica count
  selector:
    matchLabels:
      app: webapp                  # Must match template labels exactly
      component: frontend
  template:
    metadata:
      labels:
        app: webapp                # Labels for pod selection
        component: frontend
        version: "1.2.3"
    spec:
      containers:
      - name: webapp               # Container name
        image: webapp:1.2.3        # Specific image version (avoid 'latest')
        imagePullPolicy: IfNotPresent
        ports:
        - name: http               # Named port for service reference
          containerPort: 8080
          protocol: TCP
        env:
        - name: APP_ENV
          value: "production"      # Quoted environment value
        - name: LOG_LEVEL
          value: "info"
        resources:                 # Always specify resources
          requests:
            cpu: "100m"            # Quoted CPU value
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
        livenessProbe:             # Health checks
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5</code></pre></p>
<h4>Multi-Resource YAML Files</h4>
<strong>Document Separation with ---:</strong>
<pre><code><h2>Complete application stack in single file</h2>
apiVersion: v1
kind: Namespace
metadata:
  name: webapp-system
  labels:
    name: webapp-system
<p>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: webapp-config
  namespace: webapp-system
data:
  database_url: "postgresql://db-service:5432/webapp"
  cache_url: "redis://cache-service:6379"
  log_level: "info"
  app.properties: |
    server.port=8080
    management.endpoints.web.exposure.include=health,metrics
    logging.level.com.company.webapp=INFO</p>
<p>---
apiVersion: v1
kind: Secret
metadata:
  name: webapp-secrets
  namespace: webapp-system
type: Opaque
data:
  database-password: cGFzc3dvcmQxMjM=  # base64 encoded
  api-key: YWJjZGVmZ2hpams=             # base64 encoded</p>
<p>---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  namespace: webapp-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: webapp:1.2.3
        ports:
        - containerPort: 8080
          name: http
        envFrom:
        - configMapRef:
            name: webapp-config
        - secretRef:
            name: webapp-secrets
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
      volumes:
      - name: config-volume
        configMap:
          name: webapp-config
          items:
          - key: app.properties
            path: application.properties</p>
<p>---
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  namespace: webapp-system
spec:
  selector:
    app: webapp
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  type: ClusterIP</p>
<p>---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
  namespace: webapp-system
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: webapp.company.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: webapp-service
            port:
              number: 80</code></pre></p>
<h4>Advanced YAML Patterns</h4>
<strong>Environment-Specific Configurations:</strong>
<pre><code><h2>Base configuration (base/webapp.yaml)</h2>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2                    # Base replica count
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: webapp:latest      # Will be overridden per environment
        env:
        - name: LOG_LEVEL
          value: info            # Base log level
        resources:
          requests:
            cpu: 100m            # Base resource requests
            memory: 128Mi
<p>---
<h2>Development overlay (overlays/dev/webapp.yaml)</h2>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 1                    # Reduced replicas for dev
  template:
    spec:
      containers:
      - name: webapp
        image: webapp:dev-latest  # Development image
        env:
        - name: LOG_LEVEL
          value: debug           # Debug logging for dev
        - name: APP_ENV
          value: development</p>
<p>---
<h2>Production overlay (overlays/prod/webapp.yaml)</h2>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 5                    # Higher replicas for production
  template:
    spec:
      containers:
      - name: webapp
        image: webapp:1.2.3      # Specific version for production
        env:
        - name: LOG_LEVEL
          value: warn            # Reduced logging for production
        - name: APP_ENV
          value: production
        resources:
          requests:
            cpu: 200m            # Higher resource requests
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 1Gi</code></pre></p>
<strong>Resource Reference Patterns:</strong>
<pre><code><h2>Cross-resource references and dependencies</h2>
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: database-storage
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: fast-ssd
<p>---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: database
spec:
  serviceName: database-headless
  replicas: 1
  selector:
    matchLabels:
      app: database
  template:
    metadata:
      labels:
        app: database
    spec:
      containers:
      - name: database
        image: postgres:13
        env:
        - name: POSTGRES_DB
          value: webapp
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: database-credentials    # Reference to secret
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: database-credentials    # Reference to secret
              key: password
        volumeMounts:
        - name: database-storage
          mountPath: /var/lib/postgresql/data
        ports:
        - containerPort: 5432
          name: postgres
      volumes:
      - name: database-storage
        persistentVolumeClaim:
          claimName: database-storage      # Reference to PVC</p>
<p>---
apiVersion: v1
kind: Service
metadata:
  name: database-service
spec:
  selector:
    app: database                          # Reference to StatefulSet pods
  ports:
  - port: 5432
    targetPort: postgres                   # Reference to named port
    name: postgres
  type: ClusterIP</code></pre></p>
<h3>Advanced kubectl Techniques</h3>
<h4>Batch Operations and Scripting</h4>
<strong>Mass Resource Operations:</strong>
<pre><code><h2>BATCH deletions</h2>
kubectl delete pods --all                 # Delete all pods in namespace
kubectl delete pods -l app=webapp        # Delete pods by label
kubectl delete deployment,service -l app=webapp  # Multiple resource types
kubectl delete pods --field-selector=status.phase=Failed  # Delete failed pods
<h2>BATCH updates</h2>
kubectl patch pods -l app=webapp -p '{"spec":{"activeDeadlineSeconds":30}}'
kubectl label pods -l app=webapp environment=production
kubectl annotate pods -l app=webapp description="Updated batch annotation"
<h2>RESOURCE listing and processing</h2>
kubectl get pods -o name | xargs kubectl delete  # Delete using names
kubectl get pods -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\n' | xargs kubectl delete pod
<h2>NAMESPACE operations</h2>
kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\n"}{end}'
kubectl delete namespace old-project      # Deletes namespace and all resources</code></pre>
<strong>Scripting with kubectl:</strong>
<pre><code>#!/bin/bash
<h2>kubectl automation script example</h2>
<h2>Function to wait for deployment rollout</h2>
wait_for_deployment() {
    local deployment=$1
    local namespace=${2:-default}
    
    echo "Waiting for deployment $deployment in namespace $namespace..."
    kubectl rollout status deployment/$deployment -n $namespace --timeout=300s
    
    if [ $? -eq 0 ]; then
        echo "Deployment $deployment is ready"
        return 0
    else
        echo "Deployment $deployment failed or timed out"
        return 1
    fi
}
<h2>Function to check pod health</h2>
check_pod_health() {
    local label_selector=$1
    local namespace=${2:-default}
    
    local ready_pods=$(kubectl get pods -l $label_selector -n $namespace -o jsonpath='{.items[?(@.status.conditions[?(@.type=="Ready")].status=="True")].metadata.name}' | wc -w)
    local total_pods=$(kubectl get pods -l $label_selector -n $namespace --no-headers | wc -l)
    
    echo "Ready pods: $ready_pods/$total_pods"
    
    if [ $ready_pods -eq $total_pods ] && [ $total_pods -gt 0 ]; then
        return 0
    else
        return 1
    fi
}
<h2>Main deployment workflow</h2>
deploy_application() {
    local app_name=$1
    local namespace=$2
    local manifest_file=$3
    
    echo "Deploying $app_name to namespace $namespace..."
    
    # Create namespace if it doesn't exist
    kubectl create namespace $namespace --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply manifests
    kubectl apply -f $manifest_file -n $namespace
    
    # Wait for deployment
    wait_for_deployment $app_name $namespace
    
    # Check pod health
    if check_pod_health "app=$app_name" $namespace; then
        echo "Application $app_name deployed successfully!"
    else
        echo "Application $app_name deployment failed!"
        kubectl get events -n $namespace --sort-by=.metadata.creationTimestamp | tail -10
        exit 1
    fi
}
<h2>Usage example</h2>
deploy_application "webapp" "production" "webapp-manifests.yaml"</code></pre>
<h4>Resource Monitoring and Watching</h4>
<strong>Real-time Resource Monitoring:</strong>
<pre><code><h2>WATCH resources for changes</h2>
kubectl get pods -w                       # Watch pod changes
kubectl get events -w                     # Watch events in real-time
kubectl get pods -w -o wide               # Watch with additional columns
<h2>WATCH with filtering</h2>
kubectl get pods -w -l app=webapp         # Watch specific labeled pods
kubectl get events -w --field-selector=type=Warning  # Watch warning events
<h2>CONTINUOUS monitoring scripts</h2>
watch -n 2 'kubectl get pods'             # Refresh every 2 seconds
watch -n 5 'kubectl top nodes'            # Monitor node resources
<h2>CUSTOM monitoring commands</h2>
kubectl get pods -w -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,RESTARTS:.status.containerStatuses[0].restartCount</code></pre>
<strong>Resource Diff and Validation:</strong>
<pre><code><h2>DIFF before applying changes</h2>
kubectl diff -f updated-webapp.yaml       # Show differences
<h2>VALIDATE resources</h2>
kubectl apply --dry-run=server -f webapp.yaml  # Server-side validation
kubectl apply --dry-run=client -f webapp.yaml  # Client-side validation
kubectl apply --validate=true -f webapp.yaml   # Enable validation
<h2>RESOURCE comparison</h2>
kubectl get deployment webapp -o yaml > current-webapp.yaml
diff current-webapp.yaml desired-webapp.yaml</code></pre>
<h4>Plugin System and Extensions</h4>
<strong>kubectl Plugin Architecture:</strong>
<pre><code><h2>LIST available plugins</h2>
kubectl plugin list
<h2>INSTALL plugins (example: krew plugin manager)</h2>
kubectl krew install access-matrix         # RBAC analysis
kubectl krew install tree                  # Resource hierarchy
kubectl krew install tail                  # Multi-pod log tailing
kubectl krew install ctx                   # Context switching
kubectl krew install ns                    # Namespace switching
<h2>CUSTOM plugin creation (kubectl-<plugin-name>)</h2>
#!/bin/bash
<h2>Save as kubectl-pod-shell in PATH</h2>
<h2>Usage: kubectl pod-shell <pod-name></h2>
<p>POD_NAME=$1
if [ -z "$POD_NAME" ]; then
    echo "Usage: kubectl pod-shell <pod-name>"
    exit 1
fi</p>
<p>kubectl exec -it $POD_NAME -- /bin/bash 2>/dev/null || \
kubectl exec -it $POD_NAME -- /bin/sh 2>/dev/null || \
kubectl exec -it $POD_NAME -- sh</code></pre></p>
<h3>Exam-Specific kubectl Mastery</h3>
<h4>Time-Saving Techniques</h4>
<strong>Shell Aliases and Functions:</strong>
<pre><code><h2>Add to ~/.bashrc or ~/.zshrc</h2>
alias k='kubectl'
alias kg='kubectl get'
alias kd='kubectl describe'
alias kdel='kubectl delete'
alias kaf='kubectl apply -f'
alias kdry='kubectl --dry-run=client -o yaml'
<h2>Advanced aliases</h2>
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'
alias kgn='kubectl get nodes'
alias kge='kubectl get events --sort-by=.metadata.creationTimestamp'
<h2>Functions for common operations</h2>
kexec() {
    kubectl exec -it $1 -- ${2:-/bin/bash}
}
<p>klogs() {
    kubectl logs $1 ${2:+-c $2} -f
}</p>
<p>kdebug() {
    kubectl run debug-$RANDOM --image=busybox --rm -it -- /bin/sh
}</p>
<h2>Context and namespace switching</h2>
kctx() {
    if [ $# -eq 0 ]; then
        kubectl config get-contexts
    else
        kubectl config use-context $1
    fi
}
<p>kns() {
    if [ $# -eq 0 ]; then
        kubectl get namespaces
    else
        kubectl config set-context --current --namespace=$1
    fi
}</code></pre></p>
<strong>Quick Resource Templates:</strong>
<pre><code><h2>Environment variables for faster command building</h2>
export POD_TEMPLATE='--dry-run=client -o yaml'
export SVC_TEMPLATE='--dry-run=client -o yaml'
<h2>Quick deployment creation</h2>
quick_deploy() {
    local name=$1
    local image=$2
    local replicas=${3:-1}
    
    kubectl create deployment $name --image=$image --replicas=$replicas $POD_TEMPLATE
}
<h2>Quick service creation</h2>
quick_svc() {
    local name=$1
    local port=$2
    local target_port=${3:-$port}
    local type=${4:-ClusterIP}
    
    kubectl create service $type $name --tcp=$port:$target_port $SVC_TEMPLATE
}
<h2>Usage examples:</h2>
<h2>quick_deploy webapp nginx:1.21 3 > webapp-deployment.yaml</h2>
<h2>quick_svc webapp 80 8080 NodePort > webapp-service.yaml</h2></code></pre>
<h4>Exam Strategy Patterns</h4>
<strong>Resource Generation Workflow:</strong>
<pre><code><h2>1. Generate base YAML</h2>
kubectl create deployment webapp --image=nginx:1.21 --dry-run=client -o yaml > webapp.yaml
<h2>2. Edit the file (add resources, labels, etc.)</h2>
vim webapp.yaml
<h2>3. Validate before applying</h2>
kubectl apply --dry-run=server -f webapp.yaml
<h2>4. Apply the configuration</h2>
kubectl apply -f webapp.yaml
<h2>5. Verify deployment</h2>
kubectl get deployment webapp
kubectl rollout status deployment webapp</code></pre>
<strong>Troubleshooting Workflow:</strong>
<pre><code><h2>Standard troubleshooting sequence</h2>
troubleshoot_pod() {
    local pod=$1
    
    echo "=== Pod Status ==="
    kubectl get pod $pod -o wide
    
    echo "=== Pod Description ==="
    kubectl describe pod $pod
    
    echo "=== Pod Events ==="
    kubectl get events --field-selector involvedObject.name=$pod
    
    echo "=== Pod Logs ==="
    kubectl logs $pod --previous 2>/dev/null || kubectl logs $pod
    
    echo "=== Container Processes ==="
    kubectl exec $pod -- ps aux 2>/dev/null || echo "Cannot access container"
}
<h2>Usage: troubleshoot_pod webapp-123</h2></code></pre>
<strong>Multi-Resource Management:</strong>
<pre><code><h2>Create complete application stack</h2>
create_app_stack() {
    local app_name=$1
    local image=$2
    local namespace=${3:-default}
    
    # Create namespace
    kubectl create namespace $namespace --dry-run=client -o yaml | kubectl apply -f -
    
    # Create deployment
    kubectl create deployment $app_name --image=$image -n $namespace
    
    # Create service
    kubectl expose deployment $app_name --port=80 --target-port=8080 -n $namespace
    
    # Create ingress
    kubectl create ingress $app_name --rule="$app_name.local/*=$app_name:80" -n $namespace
    
    echo "Application stack created for $app_name in namespace $namespace"
}</code></pre>
<h3>YAML Validation and Testing</h3>
<h4>Schema Validation</h4>
<strong>Built-in Validation:</strong>
<pre><code><h2>Client-side validation (basic)</h2>
kubectl apply --dry-run=client -f webapp.yaml
<h2>Server-side validation (comprehensive)</h2>
kubectl apply --dry-run=server -f webapp.yaml
<h2>Strict validation</h2>
kubectl apply --validate=strict -f webapp.yaml
<h2>Validation with warnings</h2>
kubectl apply --warnings-as-errors -f webapp.yaml</code></pre>
<strong>Custom Validation Tools:</strong>
<pre><code><h2>kubeval - Kubernetes YAML validation</h2>
kubeval webapp.yaml
kubeval manifests/*.yaml
<h2>kube-score - Best practices analysis</h2>
kube-score score webapp.yaml
kube-score score --output-format ci webapp.yaml
<h2>conftest - Policy-based validation using OPA</h2>
conftest verify --policy policy/ webapp.yaml
<h2>Example policy (policy/deployment.rego)</h2>
package main
<p>deny[msg] {
    input.kind == "Deployment"
    not input.spec.template.spec.containers[_].resources.limits
    msg := "Containers must have resource limits"
}</p>
<p>deny[msg] {
    input.kind == "Deployment"
    input.spec.template.spec.containers[_].image
    contains(input.spec.template.spec.containers[_].image, ":latest")
    msg := "Containers should not use 'latest' tag"
}</code></pre></p>
<h4>Testing and Verification</h4>
<strong>Resource Testing Patterns:</strong>
<pre><code><h2>Test resource creation</h2>
test_resource_creation() {
    local manifest=$1
    
    echo "Testing resource creation for $manifest..."
    
    # Validate YAML syntax
    if ! kubectl apply --dry-run=client -f $manifest > /dev/null 2>&1; then
        echo "YAML syntax validation failed"
        return 1
    fi
    
    # Validate against cluster
    if ! kubectl apply --dry-run=server -f $manifest > /dev/null 2>&1; then
        echo "Cluster validation failed"
        return 1
    fi
    
    echo "Resource validation passed"
    return 0
}
<h2>Test application functionality</h2>
test_application() {
    local app_name=$1
    local namespace=${2:-default}
    
    echo "Testing application $app_name in namespace $namespace..."
    
    # Check if pods are running
    local running_pods=$(kubectl get pods -l app=$app_name -n $namespace -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
    if [ $running_pods -eq 0 ]; then
        echo "No running pods found"
        return 1
    fi
    
    # Check if service is accessible
    local service_ip=$(kubectl get service $app_name -n $namespace -o jsonpath='{.spec.clusterIP}')
    if ! kubectl run test-$RANDOM --image=busybox --rm -it -- wget -q --timeout=5 -O - $service_ip > /dev/null 2>&1; then
        echo "Service not accessible"
        return 1
    fi
    
    echo "Application test passed"
    return 0
}</code></pre>
<h3>Exam Tips & Quick Reference</h3>
<h4>⚡ Essential Command Shortcuts</h4>
<pre><code><h2>Resource shortcuts</h2>
k get po                          # kubectl get pods
k get svc                         # kubectl get services  
k get deploy                      # kubectl get deployments
k get no                          # kubectl get nodes
<h2>Output shortcuts</h2>
k get po -o wide                  # Extended output
k get po -o yaml                  # YAML output
k get po -o json                  # JSON output
k get po --show-labels            # Show labels
<h2>Quick operations</h2>
k run test --image=busybox --rm -it -- sh    # Temporary pod
k create deploy app --image=nginx --dry-run=client -o yaml
k expose deploy app --port=80 --target-port=8080
k scale deploy app --replicas=3
<h2>Debugging shortcuts</h2>
k describe po <pod-name>          # Pod details
k logs <pod-name> -f              # Follow logs
k exec -it <pod-name> -- /bin/bash   # Shell access
k get events --sort-by=.metadata.creationTimestamp</code></pre>
<h4>🎯 Common Exam Patterns</h4>
<strong>Pattern 1: Create Resource from Scratch</strong>
<pre><code><h2>Generate YAML template</h2>
kubectl create deployment webapp --image=nginx:1.21 --dry-run=client -o yaml > webapp.yaml
<h2>Edit file to add required specifications</h2>
vim webapp.yaml
<h2>Apply and verify</h2>
kubectl apply -f webapp.yaml
kubectl get deployment webapp</code></pre>
<strong>Pattern 2: Modify Existing Resource</strong>
<pre><code><h2>Export current configuration</h2>
kubectl get deployment webapp -o yaml > webapp-current.yaml
<h2>Edit configuration</h2>
vim webapp-current.yaml
<h2>Apply changes</h2>
kubectl apply -f webapp-current.yaml
<h2>Or use direct edit</h2>
kubectl edit deployment webapp</code></pre>
<strong>Pattern 3: Troubleshoot Resource</strong>
<pre><code><h2>Standard troubleshooting sequence</h2>
kubectl get pods
kubectl describe pod <pod-name>
kubectl logs <pod-name>
kubectl get events</code></pre>
<h4>🚨 Critical Gotchas</h4>
<p>1. <strong>YAML Indentation</strong>: Must be consistent (2 spaces recommended)
2. <strong>Quotes in YAML</strong>: Quote strings that look like numbers ("80", "1.0")
3. <strong>Label Selectors</strong>: Deployment selector must match pod template labels exactly
4. <strong>Resource Names</strong>: Must be DNS-1123 compliant (lowercase, numbers, hyphens)
5. <strong>Namespace Context</strong>: Always verify current namespace context
6. <strong>Dry-run Validation</strong>: Use server-side dry-run for complete validation
7. <strong>Resource Limits</strong>: Always specify in production manifests</p>
<h3>WHY This Matters - The Deeper Philosophy</h3>
<h4>The Command Line as Universal Interface</h4>
<strong>The Unix Philosophy Applied:</strong>
<pre><code>"Everything is a file" → "Everything is a resource"
├── Consistent interface patterns across all resource types
├── Composable commands for complex operations
├── Pipeable output for automation and scripting
├── Text-based configuration for version control
└── Human-readable formats for debugging and learning
<p>kubectl embodies these principles:
├── Unified CRUD operations across all resources
├── Consistent output formatting options
├── Composable with standard Unix tools
├── Infrastructure as Code enablement
└── Learning through exploration and experimentation</code></pre></p>
<strong>The Abstraction Ladder:</strong>
<pre><code>Level 5: Business Logic (Applications, Services)
Level 4: Kubernetes Resources (Deployments, Services, Pods)
Level 3: kubectl Commands (Imperative operations)
Level 2: YAML Manifests (Declarative state)
Level 1: Kubernetes API (REST endpoints)
Level 0: etcd Storage (Distributed key-value store)
<p>kubectl bridges levels 2-4, making complex distributed systems accessible
through simple, intuitive commands and readable configuration files.</code></pre></p>
<h4>Configuration as Code Philosophy</h4>
<strong>The Infrastructure as Code Evolution:</strong>
<pre><code>Manual Operations → Scripts → Configuration Management → Infrastructure as Code → GitOps
       │              │              │                        │                │
   Snowflake       Runbooks      Ansible/Chef           Terraform/Helm      Kubernetes + Git
   Servers         Scripts       Playbooks              Templates           Manifests</code></pre>
<strong>YAML as the Universal Configuration Language:</strong>
<pre><code>YAML Design Principles:
├── Human-readable and writable
├── Machine-parseable and validatable
├── Hierarchical data representation
├── Comment support for documentation
├── Consistent syntax across tools
└── Version control friendly
<p>Why YAML Won in Kubernetes:
├── Lower barrier to entry than JSON
├── More expressive than environment variables
├── Less verbose than XML
├── Better tooling ecosystem than TOML
└── Industry standardization momentum</code></pre></p>
<h4>The Cognitive Load Reduction Model</h4>
<strong>Command Complexity Management:</strong>
<pre><code>Beginner: kubectl get pods
├── Single resource type
├── Default output format
├── Current namespace only
└── Minimal cognitive load
<p>Intermediate: kubectl get pods -l app=webapp -o wide --sort-by=.metadata.creationTimestamp
├── Filtered resource selection
├── Custom output format
├── Sorted results
└── Moderate cognitive load</p>
<p>Expert: kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\t"}{.spec.nodeName}{"\n"}{end}' | column -t
├── Custom data extraction
├── Formatted output processing
├── Pipeline composition
└── High cognitive load</p>
<p>The progression allows learning through increasing complexity
while maintaining the same fundamental command patterns.</code></pre></p>
<h4>Production Engineering Impact</h4>
<strong>The Operational Excellence Model:</strong>
<pre><code>Reactive Operations:
├── Manual resource creation and modification
├── Imperative commands for problem resolution
├── Individual heroics during incidents
├── Tribal knowledge in people's heads
└── High operational overhead
<p>Proactive Operations:
├── Declarative infrastructure definitions
├── Automated deployment and scaling
├── Standardized incident response procedures
├── Documented runbooks and procedures
└── Self-service capabilities for development teams</p>
<p>kubectl and YAML enable the transition from reactive to proactive
operations by making infrastructure programmable and reproducible.</code></pre></p>
<strong>The Learning and Sharing Economy:</strong>
<pre><code>Knowledge Transfer Efficiency:
├── YAML manifests capture operational knowledge
├── git repositories become operational documentation
├── Code reviews improve infrastructure quality
├── Pull requests enable collaborative operations
├── Version history provides audit trails
└── Reproducible environments reduce onboarding time
<p>Career Development Acceleration:
├── Transferable skills across organizations
├── Industry-standard tooling and patterns
├── Open source contribution opportunities
├── Community learning and knowledge sharing
└── Vendor-neutral skill development</code></pre></p>
<h4>Career Development Implications</h4>
<strong>For the Exam:</strong>
<ul><li><strong>Command Fluency</strong>: Master kubectl patterns for speed and accuracy</li>
<li><strong>YAML Proficiency</strong>: Write correct manifests quickly and confidently</li>
<li><strong>Debugging Skills</strong>: Use kubectl effectively for problem diagnosis</li>
<li><strong>Pattern Recognition</strong>: Identify common resource configurations and relationships</li>
<strong>For Production Systems:</strong>
<li><strong>Automation</strong>: Enable GitOps and Infrastructure as Code workflows</li>
<li><strong>Reliability</strong>: Create reproducible, testable infrastructure configurations</li>
<li><strong>Collaboration</strong>: Facilitate team knowledge sharing through code reviews</li>
<li><strong>Standardization</strong>: Establish consistent patterns across applications and teams</li>
<strong>For Your Career:</strong>
<li><strong>Versatility</strong>: kubectl skills transfer across any Kubernetes environment</li>
<li><strong>Leadership</strong>: Guide teams in adopting infrastructure as code practices</li>
<li><strong>Innovation</strong>: Design novel deployment patterns and operational workflows</li>
<li><strong>Mentoring</strong>: Teach others the principles behind effective kubectl usage</li></ul>
<p>Understanding kubectl and YAML deeply teaches you how to <strong>communicate effectively with distributed systems</strong> through code. This knowledge is fundamental to the CKA exam and essential for anyone working with modern cloud-native infrastructure.</p>
<p>These tools represent the democratization of complex systems management - making powerful distributed systems accessible through simple, learnable interfaces. Master these skills, and you master the primary interface to the cloud-native world.</p>
            </div>
        </div>
        
        <div class="note-footer">
            <p><a href="../index.html">← Back to Alex Susanu's Knowledge Base</a></p>
        </div>
    </div>
</body>
</html>