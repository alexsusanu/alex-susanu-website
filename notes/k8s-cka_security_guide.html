<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CKA Guide: Kubernetes Security - RBAC, ServiceAccounts, SecurityContext & NetworkPolicies - Alex Susanu</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <style>
        /* Note-specific styles that extend the main CSS */
        .note-page {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .note-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }
        
        .note-header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .back-nav {
            background: #f8f9ff;
            padding: 15px 30px;
            border-bottom: 2px solid #e8f0ff;
        }
        
        .back-btn {
            background: #4a90e2;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: #357abd;
        }
        
        .note-content-wrapper {
            padding: 40px 30px;
        }
        
        .note-meta {
            color: #666;
            font-style: italic;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e8f0ff;
        }
        
        .note-footer {
            background: #f8f9ff;
            padding: 20px 30px;
            text-align: center;
            color: #666;
            border-top: 2px solid #e8f0ff;
        }
    </style>
</head>
<body class="note-page">
    <div class="note-container">
        <div class="note-header">
            <h1>CKA Guide: Kubernetes Security - RBAC, ServiceAccounts, SecurityContext & NetworkPolicies</h1>
        </div>
        
        <div class="back-nav">
            <a href="../index.html" class="back-btn">← Back to Knowledge Base</a>
        </div>
        
        <div class="note-content-wrapper">
            <div class="note-meta">
                Kubernetes Certification (k8s) • Updated June 02, 2025
            </div>
            
            <div class="note-tags">
                <span class="tag">cka</span><span class="tag">kubernetes</span><span class="tag">exam</span><span class="tag">kubectl</span><span class="tag">certification</span>
            </div>
            
            <div class="note-content">
                <h2>CKA Guide: Kubernetes Security - RBAC, ServiceAccounts, SecurityContext & NetworkPolicies</h2>
<h3>Fundamental Conceptual Understanding</h3>
<h4>The Defense in Depth Security Model</h4>
<strong>Kubernetes Security Layers:</strong>
<pre><code>Layer 7: Application Security
├── Application-level authentication and authorization
├── Input validation and sanitization
├── Secure coding practices
├── Dependency vulnerability management
└── Runtime application security monitoring
<p>Layer 6: Pod Security
├── SecurityContext: Container runtime security
├── Pod Security Standards: Policy enforcement
├── Resource limits: DoS prevention
├── Image security: Vulnerability scanning
└── Secrets management: Sensitive data protection</p>
<p>Layer 5: Network Security
├── NetworkPolicies: Micro-segmentation
├── Service mesh: mTLS and traffic encryption
├── Ingress security: TLS termination and WAF
├── CNI security: Network plugin hardening
└── East-west traffic control: Pod-to-pod communication</p>
<p>Layer 4: Access Control
├── RBAC: Role-based access control
├── ServiceAccounts: Pod identity and permissions
├── Admission Controllers: Policy enforcement at API level
├── Authentication: Identity verification
└── Authorization: Permission validation</p>
<p>Layer 3: Node Security
├── Node hardening: OS security configurations
├── Container runtime security: CRI security
├── kubelet security: API and certificate management
├── Host filesystem protection: Read-only root filesystems
└── Kernel security: Seccomp and AppArmor profiles</p>
<p>Layer 2: Cluster Security
├── API server security: TLS and certificate management
├── etcd security: Encryption at rest and in transit
├── Control plane isolation: Network and compute separation
├── Audit logging: Security event monitoring
└── Certificate rotation: PKI lifecycle management</p>
<p>Layer 1: Infrastructure Security
├── Cloud provider security: IAM and network controls
├── Physical security: Data center and hardware protection
├── Supply chain security: Software and hardware provenance
├── Compliance: Regulatory and industry standards
└── Incident response: Security operations and forensics</code></pre></p>
<strong>The Principle of Least Privilege:</strong>
<pre><code>Traditional "God Mode" Approach:
├── Broad, permissive access controls
├── Shared administrative accounts
├── Long-lived, static credentials
├── Minimal access monitoring
└── Reactive security posture
<p>Zero Trust Security Model:
├── Minimal required permissions only
├── Identity-based access control
├── Short-lived, rotated credentials
├── Continuous access validation
├── Proactive threat detection
└── Assume breach mentality</p>
<p>Kubernetes Implementation:
├── RBAC: Granular permissions per user/service
├── ServiceAccounts: Dedicated identity per workload
├── NetworkPolicies: Default-deny network segmentation
├── SecurityContext: Minimal container privileges
└── Admission Controllers: Policy enforcement at creation time</code></pre></p>
<h4>Security Information Flow</h4>
<strong>Authentication, Authorization, and Admission Control:</strong>
<pre><code>Kubernetes Request Security Pipeline:
<p>1. Authentication: "Who are you?"
   ├── X.509 certificates (mutual TLS)
   ├── Bearer tokens (ServiceAccount tokens, OIDC)
   ├── Basic authentication (username/password)
   ├── External authentication (webhook, proxy)
   └── Anonymous access (if enabled)</p>
<p>2. Authorization: "What can you do?"
   ├── RBAC (Role-Based Access Control)
   ├── ABAC (Attribute-Based Access Control)
   ├── Node authorization (kubelet permissions)
   ├── Webhook authorization (external policy)
   └── AlwaysAllow/AlwaysDeny (testing only)</p>
<p>3. Admission Control: "How can you do it?"
   ├── Validating Admission: Policy validation
   ├── Mutating Admission: Request modification
   ├── Pod Security Standards: Runtime security policies
   ├── Resource Quotas: Resource limit enforcement
   └── Custom Admission Controllers: Organization policies</p>
<p>Request Flow:
kubectl/Client → API Server → Authentication → Authorization → Admission → etcd
                                    ↓              ↓           ↓
                               "Valid User"   "Allowed"  "Compliant"</code></pre></p>
<h3>Role-Based Access Control (RBAC)</h3>
<h4>RBAC Architecture and Components</h4>
<strong>RBAC Component Model:</strong>
<pre><code>RBAC Building Blocks:
<p>Subjects (Who):
├── User: Human users (certificate CN, OIDC claims)
├── Group: Collection of users (certificate O, OIDC groups)
├── ServiceAccount: Pod/application identity
└── system:* accounts: Built-in Kubernetes identities</p>
<p>Resources (What):
├── API Groups: Core, apps, extensions, etc.
├── Resource Types: pods, services, deployments, etc.
├── Resource Names: Specific resource instances
├── Subresources: logs, exec, portforward, etc.
└── Non-resource URLs: /api, /version, /healthz, etc.</p>
<p>Verbs (How):
├── get, list, watch: Read operations
├── create, update, patch: Write operations
├── delete, deletecollection: Removal operations
├── bind, escalate: Special RBAC operations
└── * (all): Wildcard for all verbs</p>
<p>Rules: Combinations of resources and verbs
Roles: Collections of rules (namespace-scoped)
ClusterRoles: Collections of rules (cluster-scoped)
Bindings: Associate subjects with roles</code></pre></p>
<strong>RBAC Permission Model:</strong>
<pre><code>Permission Evaluation:
├── Explicit ALLOW only (no implicit permissions)
├── No DENY rules (everything not allowed is denied)
├── Union of all applicable rules (additive permissions)
├── Namespace-scoped vs cluster-scoped resources
└── API group and version specific permissions
<p>Inheritance and Scope:
├── ClusterRole: Applies across entire cluster
├── Role: Applies within specific namespace
├── ClusterRoleBinding: Binds subjects to ClusterRoles globally
├── RoleBinding: Binds subjects to Roles/ClusterRoles in namespace
└── ServiceAccount: Automatically bound in its namespace</code></pre></p>
<h4>RBAC Configuration Patterns</h4>
<strong>Basic Role and RoleBinding:</strong>
<pre><code><h2>Namespace-scoped role for pod management</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: development
  name: pod-manager
rules:
<h2>Pod management permissions</h2>
<ul><li>apiGroups: [""]</li>
  resources: ["pods"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
<h2>Pod logs and exec access</h2>
<li>apiGroups: [""]</li>
  resources: ["pods/log", "pods/exec"]
  verbs: ["get", "create"]
<h2>ConfigMap and Secret read access</h2>
<li>apiGroups: [""]</li>
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
<h2>Service management</h2>
<li>apiGroups: [""]</li>
  resources: ["services"]
  verbs: ["get", "list", "watch", "create", "update", "patch"]
<p>---
<h2>Bind role to user</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: pod-manager-binding
  namespace: development
subjects:
<li>kind: User</li>
  name: developer@company.com
  apiGroup: rbac.authorization.k8s.io
<li>kind: Group</li>
  name: development-team
  apiGroup: rbac.authorization.k8s.io
<li>kind: ServiceAccount</li>
  name: deployment-service-account
  namespace: development
roleRef:
  kind: Role
  name: pod-manager
  apiGroup: rbac.authorization.k8s.io</code></pre></p>
<strong>ClusterRole for Cluster-Wide Permissions:</strong>
<pre><code><h2>Cluster-wide read-only access</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-reader
rules:
<h2>Read access to most resources</h2>
<li>apiGroups: [""]</li>
  resources: ["*"]
  verbs: ["get", "list", "watch"]
<li>apiGroups: ["apps"]</li>
  resources: ["*"]
  verbs: ["get", "list", "watch"]
<li>apiGroups: ["extensions"]</li>
  resources: ["*"]
  verbs: ["get", "list", "watch"]
<h2>Node information access</h2>
<li>apiGroups: [""]</li>
  resources: ["nodes"]
  verbs: ["get", "list", "watch"]
<h2>Non-resource URLs</h2>
<li>nonResourceURLs: ["/api/<em>", "/apis/</em>", "/version", "/healthz"]</li>
  verbs: ["get"]
<h2>Exclude sensitive resources</h2>
<h2>(Note: This is accomplished by NOT including them in rules)</h2>
<h2>- secrets (excluded for security)</h2>
<h2>- persistentvolumes (excluded for data protection)</h2>
<p>---
<h2>Bind ClusterRole to subjects</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-reader-binding
subjects:
<li>kind: User</li>
  name: readonly-user@company.com
  apiGroup: rbac.authorization.k8s.io
<li>kind: Group</li>
  name: monitoring-team
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-reader
  apiGroup: rbac.authorization.k8s.io</code></pre></p>
<strong>Advanced RBAC Patterns:</strong>
<strong>Resource Name Restrictions:</strong>
<pre><code><h2>Role with specific resource name access</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: specific-resource-manager
rules:
<h2>Access to specific named resources only</h2>
<li>apiGroups: [""]</li>
  resources: ["configmaps"]
  resourceNames: ["app-config", "database-config"]
  verbs: ["get", "update", "patch"]
<h2>Access to specific secrets</h2>
<li>apiGroups: [""]</li>
  resources: ["secrets"]
  resourceNames: ["app-tls-secret", "database-credentials"]
  verbs: ["get"]
<h2>Full access to pods (no name restriction)</h2>
<li>apiGroups: [""]</li>
  resources: ["pods"]
  verbs: ["*"]</code></pre>
<strong>Multi-Namespace Role Access:</strong>
<pre><code><h2>ClusterRole for multi-namespace access</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: multi-namespace-deployer
rules:
<li>apiGroups: ["apps"]</li>
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
<li>apiGroups: [""]</li>
  resources: ["pods", "services", "configmaps"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
<p>---
<h2>RoleBinding in development namespace</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: deployer-dev
  namespace: development
subjects:
<li>kind: User</li>
  name: deployer@company.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: multi-namespace-deployer
  apiGroup: rbac.authorization.k8s.io</p>
<p>---
<h2>RoleBinding in staging namespace</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: deployer-staging
  namespace: staging
subjects:
<li>kind: User</li>
  name: deployer@company.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: multi-namespace-deployer
  apiGroup: rbac.authorization.k8s.io</code></pre></p>
<strong>Custom Resource Access:</strong>
<pre><code><h2>Role for custom resource management</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: custom-resource-manager
rules:
<h2>Custom resource definitions</h2>
<li>apiGroups: ["apiextensions.k8s.io"]</li>
  resources: ["customresourcedefinitions"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
<h2>Specific custom resources</h2>
<li>apiGroups: ["example.com"]</li>
  resources: ["myresources"]
  verbs: ["*"]
<h2>Istio resources (if using service mesh)</h2>
<li>apiGroups: ["networking.istio.io"]</li>
  resources: ["virtualservices", "destinationrules", "gateways"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
<h2>Cert-manager resources (if using)</h2>
<li>apiGroups: ["cert-manager.io"]</li>
  resources: ["certificates", "certificaterequests", "issuers"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]</code></pre>
<h4>Built-in Roles and System Accounts</h4>
<strong>Default ClusterRoles:</strong>
<pre><code><h2>View built-in cluster roles</h2>
<h2>kubectl get clusterroles</h2>
<h2>Key built-in ClusterRoles:</h2>
cluster-admin:        # Superuser access to all resources
├── Full access to all resources in all API groups
├── Can create and modify RBAC rules
├── Should be used sparingly and only for break-glass access
└── Default binding: system:masters group
<p>admin:               # Namespace admin access
├── Full access to most resources within namespace
├── Can create roles and role bindings within namespace
├── Cannot modify resource quotas or namespace itself
└── Good for namespace owners/administrators</p>
<p>edit:                # Read/write access to most resources
├── Can create, modify, and delete most resources
├── Cannot view or modify roles, role bindings, or secrets
├── Cannot access pod logs or exec into containers
└── Good for developers who need to modify resources</p>
<p>view:                # Read-only access to most resources
├── Can view most resources but not secrets
├── Cannot modify any resources
├── Cannot access pod logs or exec capabilities
└── Good for monitoring and troubleshooting roles</p>
<p>system:*:            # System component roles
├── system:kube-controller-manager
├── system:kube-scheduler
├── system:node (for kubelet)
└── Various system service accounts</code></pre></p>
<strong>System ServiceAccounts:</strong>
<pre><code><h2>View system service accounts</h2>
kubectl get serviceaccounts --all-namespaces | grep system
<h2>Key system service accounts:</h2>
default                    # Default SA for pods (minimal permissions)
system:serviceaccount:kube-system:*  # System component service accounts
<h2>Check what permissions a service account has</h2>
kubectl auth can-i --list --as=system:serviceaccount:kube-system:default</code></pre>
<h4>RBAC Debugging and Auditing</h4>
<strong>Permission Testing:</strong>
<pre><code><h2>Test current user permissions</h2>
kubectl auth can-i create pods
kubectl auth can-i create pods --namespace=production
kubectl auth can-i '<em>' '</em>'  # Check if cluster admin
<h2>Test specific user permissions</h2>
kubectl auth can-i create deployments --as=user@company.com
kubectl auth can-i delete pods --as=system:serviceaccount:default:webapp
<h2>List all permissions for user</h2>
kubectl auth can-i --list
kubectl auth can-i --list --as=user@company.com
<h2>Test access to specific resources</h2>
kubectl auth can-i get pods/log
kubectl auth can-i create pods/exec
<h2>Test non-resource URL access</h2>
kubectl auth can-i get /api/v1/</code></pre>
<strong>RBAC Analysis:</strong>
<pre><code><h2>View role bindings for a user</h2>
kubectl get rolebindings,clusterrolebindings -o wide | grep user@company.com
<h2>Describe role content</h2>
kubectl describe role pod-manager -n development
kubectl describe clusterrole cluster-admin
<h2>View all subjects bound to a role</h2>
kubectl describe rolebinding pod-manager-binding -n development
kubectl describe clusterrolebinding cluster-admin
<h2>Find all permissions for a service account</h2>
kubectl describe clusterrolebinding | grep -A 10 system:serviceaccount:kube-system:default</code></pre>
<strong>RBAC Troubleshooting:</strong>
<pre><code><h2>Common RBAC errors and debugging:</h2>
<h2>Error: "User cannot create pods"</h2>
<h2>1. Check if user is authenticated</h2>
kubectl config view --minify
<h2>2. Check user's permissions</h2>
kubectl auth can-i create pods --as=user@company.com
<h2>3. Check existing role bindings</h2>
kubectl get rolebindings,clusterrolebindings -o wide | grep user@company.com
<h2>4. Check role contents</h2>
kubectl describe role <role-name> -n <namespace>
<h2>Error: "ServiceAccount cannot access secrets"</h2>
<h2>1. Check service account permissions</h2>
kubectl auth can-i get secrets --as=system:serviceaccount:default:webapp
<h2>2. Check service account role bindings</h2>
kubectl get rolebindings -o yaml | grep -A 10 -B 10 webapp
<h2>3. Create appropriate role and binding if missing</h2>
kubectl create role secret-reader --verb=get,list --resource=secrets -n default
kubectl create rolebinding webapp-secret-reader --role=secret-reader --serviceaccount=default:webapp -n default</code></pre>
<h3>ServiceAccounts and Pod Identity</h3>
<h4>ServiceAccount Architecture</h4>
<strong>ServiceAccount Identity Model:</strong>
<pre><code>ServiceAccount Components:
├── ServiceAccount Object: Identity definition in Kubernetes
├── JWT Token: Authentication credential for API server
├── CA Certificate: API server verification
├── Token Volume: Automatic mounting in pods
├── Image Pull Secrets: Optional registry credentials
└── RBAC Bindings: Authorization permissions
<p>Automatic Token Mounting:
├── Default behavior: Token automatically mounted in pods
├── Mount path: /var/run/secrets/kubernetes.io/serviceaccount/
├── Files: token, ca.crt, namespace
├── Token refresh: Automatic rotation (Kubernetes 1.22+)
└── Disable option: automountServiceAccountToken: false</p>
<p>Identity Resolution:
├── Pod → ServiceAccount → JWT Token → API Server
├── Token contains: Namespace, ServiceAccount name, expiration
├── API server validates: Signature, expiration, issuer
└── Authorization: RBAC rules applied to ServiceAccount identity</code></pre></p>
<strong>ServiceAccount Configuration:</strong>
<pre><code><h2>Custom ServiceAccount with specific permissions</h2>
apiVersion: v1
kind: ServiceAccount
metadata:
  name: webapp-service-account
  namespace: production
  labels:
    app: webapp
    environment: production
  annotations:
    description: "Service account for webapp with limited permissions"
automountServiceAccountToken: true    # Default: true
imagePullSecrets:                     # Optional: for private registries
<li>name: private-registry-secret</li>
<p>---
<h2>Role for ServiceAccount</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: webapp-role
rules:
<h2>ConfigMap access for configuration</h2>
<li>apiGroups: [""]</li>
  resources: ["configmaps"]
  verbs: ["get", "list", "watch"]</p>
<h2>Secret access for credentials</h2>
<li>apiGroups: [""]</li>
  resources: ["secrets"]
  resourceNames: ["webapp-secrets", "database-credentials"]
  verbs: ["get"]
<h2>Service discovery</h2>
<li>apiGroups: [""]</li>
  resources: ["services", "endpoints"]
  verbs: ["get", "list", "watch"]
<h2>Pod information (for health checks)</h2>
<li>apiGroups: [""]</li>
  resources: ["pods"]
  verbs: ["get", "list"]
  resourceNames: [] # Can access pods in same namespace
<p>---
<h2>Bind ServiceAccount to Role</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: webapp-role-binding
  namespace: production
subjects:
<li>kind: ServiceAccount</li>
  name: webapp-service-account
  namespace: production
roleRef:
  kind: Role
  name: webapp-role
  apiGroup: rbac.authorization.k8s.io</p>
<p>---
<h2>Pod using custom ServiceAccount</h2>
apiVersion: v1
kind: Pod
metadata:
  name: webapp-pod
  namespace: production
spec:
  serviceAccountName: webapp-service-account
  containers:
  - name: webapp
    image: webapp:1.0
    env:
    # ServiceAccount token automatically available at:
    # /var/run/secrets/kubernetes.io/serviceaccount/token
    - name: KUBERNETES_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    ports:
    - containerPort: 8080</code></pre></p>
<h4>ServiceAccount Token Management</h4>
<strong>Token Lifecycle and Security:</strong>
<pre><code><h2>ServiceAccount with token configuration</h2>
apiVersion: v1
kind: ServiceAccount
metadata:
  name: secure-service-account
  namespace: default
<h2>Kubernetes 1.22+ automatically creates bound tokens</h2>
<h2>Kubernetes 1.24+ deprecated legacy ServiceAccount tokens</h2>
<p>---
<h2>Manual token creation (Kubernetes 1.24+)</h2>
apiVersion: v1
kind: Secret
metadata:
  name: webapp-token
  namespace: default
  annotations:
    kubernetes.io/service-account.name: secure-service-account
type: kubernetes.io/service-account-token</p>
<p>---
<h2>Pod with explicit token configuration</h2>
apiVersion: v1
kind: Pod
metadata:
  name: token-aware-pod
spec:
  serviceAccountName: secure-service-account
  automountServiceAccountToken: true
  containers:
  - name: app
    image: webapp:1.0
    env:
    # Access token programmatically
    - name: SERVICE_ACCOUNT_TOKEN
      valueFrom:
        secretKeyRef:
          name: webapp-token
          key: token
    volumeMounts:
    # Standard token mount (automatic)
    - name: kube-api-access
      mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      readOnly: true
  volumes:
  # Kubernetes automatically creates this volume
  - name: kube-api-access
    projected:
      sources:
      - serviceAccountToken:
          expirationSeconds: 3607
          path: token
      - configMap:
          name: kube-root-ca.crt
          items:
          - key: ca.crt
            path: ca.crt
      - downwardAPI:
          items:
          - path: namespace
            fieldRef:
              fieldPath: metadata.namespace</code></pre></p>
<strong>Token Usage in Applications:</strong>
<pre><code><h2>Access Kubernetes API from within pod</h2>
<h2>Token automatically mounted at /var/run/secrets/kubernetes.io/serviceaccount/</h2>
<h2>Example application code using ServiceAccount token:</h2>
#!/bin/bash
SERVICEACCOUNT_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
KUBE_CA_CERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
<h2>Call Kubernetes API</h2>
curl -H "Authorization: Bearer $SERVICEACCOUNT_TOKEN" \
     --cacert $KUBE_CA_CERT \
     https://kubernetes.default.svc.cluster.local/api/v1/namespaces/$NAMESPACE/pods
<h2>Using kubectl with ServiceAccount token</h2>
kubectl --token=$SERVICEACCOUNT_TOKEN get pods</code></pre>
<h4>Multi-Tenant ServiceAccount Patterns</h4>
<strong>Namespace Isolation with ServiceAccounts:</strong>
<pre><code><h2>Development environment ServiceAccount</h2>
apiVersion: v1
kind: ServiceAccount
metadata:
  name: developer-sa
  namespace: development
<p>---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: development
  name: developer-role
rules:
<li>apiGroups: ["", "apps", "extensions"]</li>
  resources: ["*"]
  verbs: ["*"]
<h2>Note: Full access within development namespace only</h2></p>
<p>---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: developer-binding
  namespace: development
subjects:
<li>kind: ServiceAccount</li>
  name: developer-sa
  namespace: development
roleRef:
  kind: Role
  name: developer-role
  apiGroup: rbac.authorization.k8s.io</p>
<p>---
<h2>Production environment ServiceAccount (more restrictive)</h2>
apiVersion: v1
kind: ServiceAccount
metadata:
  name: production-app-sa
  namespace: production</p>
<p>---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: production-app-role
rules:
<li>apiGroups: [""]</li>
  resources: ["configmaps"]
  verbs: ["get", "list", "watch"]
<li>apiGroups: [""]</li>
  resources: ["secrets"]
  resourceNames: ["app-secrets"]  # Only specific secrets
  verbs: ["get"]
<h2>Note: Minimal permissions for production workloads</h2></p>
<p>---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: production-app-binding
  namespace: production
subjects:
<li>kind: ServiceAccount</li>
  name: production-app-sa
  namespace: production
roleRef:
  kind: Role
  name: production-app-role
  apiGroup: rbac.authorization.k8s.io</code></pre></p>
<strong>Cross-Namespace ServiceAccount Access:</strong>
<pre><code><h2>ServiceAccount that can access multiple namespaces</h2>
apiVersion: v1
kind: ServiceAccount
metadata:
  name: multi-namespace-sa
  namespace: default
<p>---
<h2>ClusterRole for cross-namespace access</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: multi-namespace-role
rules:
<li>apiGroups: [""]</li>
  resources: ["pods", "services"]
  verbs: ["get", "list", "watch"]
<li>apiGroups: ["apps"]</li>
  resources: ["deployments"]
  verbs: ["get", "list", "watch", "update", "patch"]</p>
<p>---
<h2>ClusterRoleBinding for global access</h2>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: multi-namespace-binding
subjects:
<li>kind: ServiceAccount</li>
  name: multi-namespace-sa
  namespace: default
roleRef:
  kind: ClusterRole
  name: multi-namespace-role
  apiGroup: rbac.authorization.k8s.io</code></pre></p>
<h3>SecurityContext and Runtime Security</h3>
<h4>SecurityContext Architecture</h4>
<strong>Pod-Level vs Container-Level Security:</strong>
<pre><code>Security Context Hierarchy:
├── Pod SecurityContext: Applies to all containers in pod
│   ├── User/Group IDs for all containers
│   ├── SELinux labels for pod
│   ├── Seccomp profiles for pod
│   ├── Sysctl settings for pod
│   └── File system group permissions
├── Container SecurityContext: Overrides pod settings
│   ├── User/Group IDs for specific container
│   ├── Capabilities: Linux capabilities to add/drop
│   ├── Privileged mode: Full host access
│   ├── Read-only root filesystem
│   ├── Allow privilege escalation
│   └── SELinux options for container
└── Inheritance: Container settings override pod settings
<p>Security Enforcement:
├── Container Runtime: Enforces security context settings
├── Linux Kernel: Applies capabilities, namespaces, cgroups
├── SELinux/AppArmor: Mandatory access control
├── Seccomp: System call filtering
└── Admission Controllers: Policy validation before creation</code></pre></p>
<strong>Comprehensive Security Context Configuration:</strong>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
  annotations:
    # Pod Security Standards annotation
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
spec:
  # Pod-level security context
  securityContext:
    # User and group settings
    runAsUser: 1000                    # Non-root user ID
    runAsGroup: 3000                   # Primary group ID
    runAsNonRoot: true                 # Enforce non-root user
    fsGroup: 2000                      # File system group for volumes
    fsGroupChangePolicy: Always        # How to apply fsGroup
    
    # Supplemental groups
    supplementalGroups:
    - 4000
    - 5000
    
    # SELinux settings
    seLinuxOptions:
      level: "s0:c123,c456"            # SELinux context
      type: "container_t"
      user: "system_u"
      role: "object_r"
    
    # Seccomp profile
    seccompProfile:
      type: RuntimeDefault             # Use container runtime default
      # type: Localhost                # Use custom profile
      # localhostProfile: my-profile.json
    
    # Windows-specific settings (if applicable)
    windowsOptions:
      gmsaCredentialSpecName: gmsa-webapp
      gmsaCredentialSpec: "credspec contents"
      runAsUserName: "ContainerUser"
    
    # System controls
    sysctls:
    - name: net.core.somaxconn
      value: "1024"
    - name: kernel.shm_rmid_forced
      value: "1"
<p>containers:
  - name: webapp
    image: webapp:1.0
    
    # Container-level security context (overrides pod settings)
    securityContext:
      # User settings (override pod settings)
      runAsUser: 1001                  # Different from pod setting
      runAsGroup: 3001
      runAsNonRoot: true
      
      # Privilege settings
      privileged: false                # Never use privileged containers
      allowPrivilegeEscalation: false  # Prevent privilege escalation
      readOnlyRootFilesystem: true     # Immutable container filesystem
      
      # Linux capabilities
      capabilities:
        add:
        - NET_BIND_SERVICE             # Bind to privileged ports
        drop:
        - ALL                          # Drop all capabilities first
        # Common capabilities to drop:
        # - CHOWN, DAC_OVERRIDE, FOWNER, SETGID, SETUID, SYS_CHROOT
      
      # SELinux (container-specific)
      seLinuxOptions:
        type: "webapp_t"               # Custom SELinux type
      
      # Seccomp (container-specific)
      seccompProfile:
        type: RuntimeDefault
      
      # Proc mount type
      procMount: Default               # Default, Unmasked
    
    # Application configuration
    ports:
    - containerPort: 8080
    
    # Volume mounts with security considerations
    volumeMounts:
    - name: app-data
      mountPath: /app/data
      readOnly: false                  # Application data (read-write)
    - name: app-config
      mountPath: /app/config
      readOnly: true                   # Configuration (read-only)
    - name: tmp-volume
      mountPath: /tmp                  # Writable temp space
    - name: var-cache
      mountPath: /var/cache
      
  # Volume configuration
  volumes:
  - name: app-data
    persistentVolumeClaim:
      claimName: app-data-pvc
  - name: app-config
    configMap:
      name: app-config
      defaultMode: 0644                # Readable by group
  - name: tmp-volume
    emptyDir: {}                       # Temporary writable space
  - name: var-cache
    emptyDir: {}</code></pre></p>
<h4>Linux Capabilities Management</h4>
<strong>Capability-Based Security:</strong>
<pre><code><h2>Minimal capabilities example</h2>
apiVersion: v1
kind: Pod
metadata:
  name: minimal-capabilities-pod
spec:
  containers:
  - name: webapp
    image: nginx:1.21
    securityContext:
      capabilities:
        drop:
        - ALL                          # Drop all capabilities
        add:
        - NET_BIND_SERVICE             # Only add what's needed
      runAsNonRoot: true
      runAsUser: 101                   # nginx user
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
    ports:
    - containerPort: 80                # Can bind to port 80 with NET_BIND_SERVICE
    volumeMounts:
    - name: nginx-cache
      mountPath: /var/cache/nginx      # Writable cache directory
    - name: nginx-run
      mountPath: /var/run              # Runtime files
  volumes:
  - name: nginx-cache
    emptyDir: {}
  - name: nginx-run
    emptyDir: {}
<h2>Common Linux capabilities:</h2>
<h2>CAP_CHOWN: Change file ownership</h2>
<h2>CAP_DAC_OVERRIDE: Bypass file permission checks</h2>
<h2>CAP_FOWNER: Bypass permission checks for operations that normally require filesystem ownership</h2>
<h2>CAP_SETGID: Make arbitrary manipulations of process GIDs</h2>
<h2>CAP_SETUID: Make arbitrary manipulations of process UIDs</h2>
<h2>CAP_NET_BIND_SERVICE: Bind to ports < 1024</h2>
<h2>CAP_SYS_CHROOT: Use chroot()</h2>
<h2>CAP_KILL: Send signals to processes</h2>
<h2>CAP_AUDIT_WRITE: Write to audit log</h2></code></pre>
<strong>Network Capabilities Example:</strong>
<pre><code><h2>Pod requiring network capabilities</h2>
apiVersion: v1
kind: Pod
metadata:
  name: network-tools-pod
spec:
  containers:
  - name: network-tools
    image: nicolaka/netshoot
    securityContext:
      capabilities:
        drop:
        - ALL
        add:
        - NET_ADMIN                    # Network administration
        - NET_RAW                      # Raw network access (ping, traceroute)
        - SYS_PTRACE                   # Process tracing (debugging)
      runAsUser: 0                     # May need root for network tools
      allowPrivilegeEscalation: false
    command: ["sleep", "3600"]</code></pre>
<h4>Pod Security Standards</h4>
<strong>Pod Security Standards Levels:</strong>
<pre><code><h2>Privileged level (most permissive)</h2>
apiVersion: v1
kind: Namespace
metadata:
  name: privileged-workloads
  labels:
    pod-security.kubernetes.io/enforce: privileged
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/warn: privileged
<h2>Allows: Privileged containers, host networking, all capabilities</h2>
<p>---
<h2>Baseline level (minimally restrictive)</h2>
apiVersion: v1
kind: Namespace
metadata:
  name: baseline-workloads
  labels:
    pod-security.kubernetes.io/enforce: baseline
    pod-security.kubernetes.io/audit: baseline
    pod-security.kubernetes.io/warn: baseline
<h2>Prohibits: Privileged containers, host networking, most capabilities</h2>
<h2>Allows: Non-root users, some capabilities like NET_BIND_SERVICE</h2></p>
<p>---
<h2>Restricted level (most secure)</h2>
apiVersion: v1
kind: Namespace
metadata:
  name: restricted-workloads
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
<h2>Requires: Non-root users, read-only root filesystem, no privilege escalation</h2>
<h2>Prohibits: Most capabilities, privileged containers</h2></p>
<p>---
<h2>Pod that complies with restricted standard</h2>
apiVersion: v1
kind: Pod
metadata:
  name: restricted-compliant-pod
  namespace: restricted-workloads
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: webapp:1.0
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1000
      capabilities:
        drop:
        - ALL
      seccompProfile:
        type: RuntimeDefault
    ports:
    - containerPort: 8080
    volumeMounts:
    - name: tmp-volume
      mountPath: /tmp
  volumes:
  - name: tmp-volume
    emptyDir: {}</code></pre></p>
<h4>Advanced Security Patterns</h4>
<strong>Multi-Container Security:</strong>
<pre><code><h2>Secure multi-container pod with sidecar</h2>
apiVersion: v1
kind: Pod
metadata:
  name: secure-multi-container
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  
  containers:
  # Main application container
  - name: webapp
    image: webapp:1.0
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsUser: 1001                  # Different user than pod default
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE
    ports:
    - containerPort: 8080
    volumeMounts:
    - name: app-data
      mountPath: /app/data
    - name: tmp-volume
      mountPath: /tmp
  
  # Logging sidecar with different security context
  - name: log-forwarder
    image: fluent/fluent-bit:1.9
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsUser: 1002                  # Different user for sidecar
      capabilities:
        drop:
        - ALL
    volumeMounts:
    - name: app-data
      mountPath: /app/data
      readOnly: true                   # Sidecar only reads logs
    - name: fluent-config
      mountPath: /fluent-bit/etc
      readOnly: true
  
  volumes:
  - name: app-data
    emptyDir: {}
  - name: tmp-volume
    emptyDir: {}
  - name: fluent-config
    configMap:
      name: fluent-bit-config</code></pre>
<strong>Init Container Security:</strong>
<pre><code><h2>Secure init container pattern</h2>
apiVersion: v1
kind: Pod
metadata:
  name: secure-init-container
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
  
  # Init container with elevated permissions for setup
  initContainers:
  - name: setup
    image: busybox:1.35
    securityContext:
      runAsUser: 0                     # Root needed for setup tasks
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - CHOWN                        # Needed to change file ownership
        - DAC_OVERRIDE                 # Needed for file operations
    command:
    - sh
    - -c
    - |
      # Set up file permissions for main container
      touch /shared/app.log
      chown 1000:2000 /shared/app.log
      chmod 644 /shared/app.log
    volumeMounts:
    - name: shared-data
      mountPath: /shared
  
  # Main container runs with restricted permissions
  containers:
  - name: app
    image: webapp:1.0
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsUser: 1000                  # Non-root user
      capabilities:
        drop:
        - ALL
    volumeMounts:
    - name: shared-data
      mountPath: /app/data
  
  volumes:
  - name: shared-data
    emptyDir: {}</code></pre>
<h3>Network Policies</h3>
<h4>Network Policy Architecture</h4>
<strong>Network Segmentation Model:</strong>
<pre><code>Network Policy Concepts:
├── Default Deny: All traffic blocked unless explicitly allowed
├── Default Allow: All traffic permitted (Kubernetes default)
├── Ingress Rules: Control incoming traffic to pods
├── Egress Rules: Control outgoing traffic from pods
├── Namespace Isolation: Separate network domains
├── Pod Selection: Label-based traffic targeting
└── Policy Combination: Multiple policies are additive
<p>Traffic Types:
├── Pod-to-Pod: Communication between pods in cluster
├── Pod-to-Service: Communication via Kubernetes services
├── Pod-to-External: Communication to internet/external services
├── External-to-Pod: Ingress traffic from outside cluster
└── Namespace-to-Namespace: Cross-namespace communication</p>
<p>Rule Matching:
├── From/To: Source/destination specification
├── Ports: Protocol and port combinations
├── NamespaceSelector: Target namespaces by labels
├── PodSelector: Target pods by labels
└── IPBlock: Target external IP ranges</code></pre></p>
<strong>Network Policy Components:</strong>
<pre><code><h2>Complete network policy structure</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: comprehensive-network-policy
  namespace: production
spec:
  # Pod selection (which pods this policy applies to)
  podSelector:
    matchLabels:
      app: webapp
      tier: frontend
  
  # Policy types (what traffic to control)
  policyTypes:
  - Ingress                            # Control incoming traffic
  - Egress                             # Control outgoing traffic
  
  # Ingress rules (incoming traffic)
  ingress:
  # Rule 1: Allow from specific pods
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
    ports:
    - protocol: TCP
      port: 8080
  
  # Rule 2: Allow from specific namespaces
  - from:
    - namespaceSelector:
        matchLabels:
          environment: production
      podSelector:
        matchLabels:
          component: loadbalancer
    ports:
    - protocol: TCP
      port: 80
  
  # Rule 3: Allow from external IP range
  - from:
    - ipBlock:
        cidr: 10.0.0.0/8
        except:
        - 10.0.1.0/24                  # Exclude specific subnet
    ports:
    - protocol: TCP
      port: 443
  
  # Egress rules (outgoing traffic)
  egress:
  # Rule 1: Allow to specific pods
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 5432
  
  # Rule 2: Allow to external services
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0                # All external IPs
        except:
        - 169.254.169.254/32           # Exclude metadata service
    ports:
    - protocol: TCP
      port: 443                        # HTTPS only
    - protocol: TCP
      port: 80                         # HTTP
  
  # Rule 3: Allow DNS resolution
  - to: []                             # Any destination
    ports:
    - protocol: UDP
      port: 53                         # DNS
    - protocol: TCP
      port: 53                         # DNS over TCP</code></pre>
<h4>Common Network Policy Patterns</h4>
<strong>Default Deny All Traffic:</strong>
<pre><code><h2>Deny all ingress traffic (default deny)</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: production
spec:
  podSelector: {}                      # Applies to all pods in namespace
  policyTypes:
  - Ingress
  # No ingress rules = deny all ingress
<p>---
<h2>Deny all egress traffic</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-egress
  namespace: production
spec:
  podSelector: {}                      # Applies to all pods
  policyTypes:
  - Egress
  # No egress rules = deny all egress</p>
<p>---
<h2>Deny all ingress and egress traffic</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  # No rules = deny all traffic</code></pre></p>
<strong>Allow DNS and Common Services:</strong>
<pre><code><h2>Allow DNS resolution for all pods</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: production
spec:
  podSelector: {}                      # All pods
  policyTypes:
  - Egress
  egress:
  # Allow DNS queries to kube-system namespace
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  
  # Allow DNS queries to any IP (for external DNS)
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
<p>---
<h2>Allow access to Kubernetes API server</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-kube-api
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - ipBlock:
        cidr: 10.96.0.1/32             # API server ClusterIP
    ports:
    - protocol: TCP
      port: 443</code></pre></p>
<strong>Three-Tier Application Network Policy:</strong>
<pre><code><h2>Frontend network policy</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-netpol
  namespace: webapp
spec:
  podSelector:
    matchLabels:
      tier: frontend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow from ingress controller
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
  egress:
  # Allow to backend tier
  - to:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 8080
  # Allow DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53
<p>---
<h2>Backend network policy</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-netpol
  namespace: webapp
spec:
  podSelector:
    matchLabels:
      tier: backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow from frontend tier
  - from:
    - podSelector:
        matchLabels:
          tier: frontend
    ports:
    - protocol: TCP
      port: 8080
  egress:
  # Allow to database tier
  - to:
    - podSelector:
        matchLabels:
          tier: database
    ports:
    - protocol: TCP
      port: 5432
  # Allow to external APIs
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
    ports:
    - protocol: TCP
      port: 443
  # Allow DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53</p>
<p>---
<h2>Database network policy</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: database-netpol
  namespace: webapp
spec:
  podSelector:
    matchLabels:
      tier: database
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Only allow from backend tier
  - from:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 5432
  egress:
  # Allow DNS only (no external access)
  - to: []
    ports:
    - protocol: UDP
      port: 53</code></pre></p>
<strong>Cross-Namespace Communication:</strong>
<pre><code><h2>Allow specific cross-namespace communication</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-monitoring
  namespace: webapp
spec:
  podSelector:
    matchLabels:
      app: webapp
  policyTypes:
  - Ingress
  ingress:
  # Allow monitoring namespace to scrape metrics
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
      podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 9090                       # Metrics port
<p>---
<h2>Allow logging namespace access</h2>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-logging
  namespace: webapp
spec:
  podSelector: {}                      # All pods in namespace
  policyTypes:
  - Ingress
  ingress:
  # Allow log collection from logging namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: logging
    ports:
    - protocol: TCP
      port: 24224                      # Fluentd forward protocol</code></pre></p>
<h4>Network Policy Debugging</h4>
<strong>Testing Network Connectivity:</strong>
<pre><code><h2>Create test pods for connectivity testing</h2>
kubectl run test-client --image=busybox --rm -it -- /bin/sh
kubectl run test-server --image=nginx --port=80
<h2>Test pod-to-pod connectivity</h2>
kubectl exec -it test-client -- wget -qO- http://test-server
<h2>Test service connectivity</h2>
kubectl exec -it test-client -- wget -qO- http://test-server-service
<h2>Test external connectivity</h2>
kubectl exec -it test-client -- wget -qO- http://google.com
<h2>Test DNS resolution</h2>
kubectl exec -it test-client -- nslookup kubernetes.default
kubectl exec -it test-client -- nslookup test-server-service
<h2>Check network policy application</h2>
kubectl describe networkpolicy <policy-name>
kubectl get networkpolicy -o yaml</code></pre>
<strong>Network Policy Troubleshooting:</strong>
<pre><code><h2>Common network policy issues:</h2>
<h2>1. DNS not working after applying network policy</h2>
<h2>Solution: Add DNS egress rule</h2>
kubectl apply -f - <<EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to: []
    ports:
    - protocol: UDP
      port: 53
EOF
<h2>2. Pods can't reach Kubernetes API</h2>
<h2>Solution: Add API server egress rule</h2>
kubectl get svc kubernetes -o jsonpath='{.spec.clusterIP}'
<h2>Add egress rule for this IP on port 443</h2>
<h2>3. Cross-namespace communication blocked</h2>
<h2>Check namespace labels</h2>
kubectl get namespaces --show-labels
<h2>4. Service discovery not working</h2>
<h2>Check if service endpoints are populated</h2>
kubectl get endpoints <service-name>
<h2>5. External connectivity blocked</h2>
<h2>Check egress rules for external IP blocks</h2>
kubectl describe networkpolicy | grep -A 10 "Egress:"</code></pre>
<h3>Exam Tips & Quick Reference</h3>
<h4>⚡ Essential Security Commands</h4>
<pre><code><h2>RBAC commands</h2>
kubectl auth can-i create pods                    # Check permissions
kubectl auth can-i --list                         # List all permissions
kubectl auth can-i create pods --as=user@company.com
<h2>ServiceAccount commands</h2>
kubectl create serviceaccount webapp-sa
kubectl get serviceaccounts
kubectl describe serviceaccount webapp-sa
<h2>Security context testing</h2>
kubectl run secure-pod --image=nginx --dry-run=client -o yaml > secure-pod.yaml
<h2>Edit to add security context, then apply</h2>
<h2>Network policy testing</h2>
kubectl run test-pod --image=busybox --rm -it -- /bin/sh
<h2>Test connectivity before and after applying network policies</h2></code></pre>
<h4>🎯 Common Exam Scenarios</h4>
<strong>Scenario 1: Create RBAC for User</strong>
<pre><code><h2>Create role</h2>
kubectl create role pod-reader --verb=get,list,watch --resource=pods
<h2>Create role binding</h2>
kubectl create rolebinding pod-reader-binding --role=pod-reader --user=dev@company.com
<h2>Test permissions</h2>
kubectl auth can-i get pods --as=dev@company.com</code></pre>
<strong>Scenario 2: Secure Pod Configuration</strong>
<pre><code><h2>Generate pod with security context</h2>
kubectl run secure-app --image=nginx --dry-run=client -o yaml > secure-app.yaml
<h2>Edit to add:</h2>
<h2>- runAsNonRoot: true</h2>
<h2>- readOnlyRootFilesystem: true</h2>
<h2>- capabilities drop ALL</h2>
<h2>Then apply</h2></code></pre>
<strong>Scenario 3: Network Policy Implementation</strong>
<pre><code><h2>Create default deny policy</h2>
kubectl create -f - <<EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector: {}
  policyTypes:
  - Ingress
EOF
<h2>Test connectivity (should be blocked)</h2>
<h2>Then create specific allow policies</h2></code></pre>
<h4>🚨 Critical Gotchas</h4>
<p>1. <strong>RBAC Additive</strong>: Multiple role bindings are additive (union of permissions)
2. <strong>ServiceAccount Default</strong>: Default SA has minimal permissions
3. <strong>SecurityContext Inheritance</strong>: Container settings override pod settings
4. <strong>Network Policy CNI</strong>: Requires CNI plugin support (Calico, Cilium, etc.)
5. <strong>Default Allow</strong>: Kubernetes allows all traffic by default
6. <strong>Policy Types</strong>: Must specify both Ingress and Egress for complete control
7. <strong>DNS Access</strong>: Always allow DNS unless explicitly blocked</p>
<h3>WHY This Matters - The Deeper Philosophy</h3>
<h4>Security as Code and Shift-Left</h4>
<strong>The Evolution of Security:</strong>
<pre><code>Traditional Security (Perimeter-Based):
├── Network firewalls and DMZs
├── Host-based security after deployment
├── Reactive security patching
├── Manual security configurations
└── Security as separate operational concern
<p>Cloud-Native Security (Zero-Trust):
├── Identity-based access control
├── Security policies as code
├── Proactive security by design
├── Automated security enforcement
├── Security integrated into development workflow
└── Continuous security validation</p>
<p>Kubernetes Security Principles:
├── Defense in depth across all layers
├── Principle of least privilege by default
├── Immutable infrastructure reduces attack surface
├── Declarative security policies
├── Automated policy enforcement
└── Observable security posture</code></pre></p>
<h4>Economic Model of Security</h4>
<strong>Security ROI Calculation:</strong>
<pre><code>Security Investment Areas:
├── Prevention: RBAC, NetworkPolicies, SecurityContext
├── Detection: Audit logging, monitoring, alerting
├── Response: Incident response, forensics, recovery
├── Education: Training, awareness, best practices
└── Compliance: Auditing, reporting, certification
<p>Cost of Security Breaches:
├── Direct costs: Data loss, system downtime, recovery
├── Indirect costs: Reputation damage, customer churn
├── Regulatory costs: Fines, legal fees, compliance
├── Opportunity costs: Delayed features, market share
└── Insurance costs: Higher premiums, coverage gaps</p>
<p>Kubernetes Security Benefits:
├── Automated policy enforcement reduces human error
├── Consistent security across environments
├── Audit trails for compliance and forensics
├── Rapid response through automation
└── Lower operational overhead through standardization</code></pre></p>
<h4>Production Engineering Philosophy</h4>
<strong>Security as Enabler, Not Blocker:</strong>
<pre><code>Traditional Security Approach:
├── Security policies slow development
├── Manual approval processes
├── Security team as gatekeeper
├── "Security says no" culture
└── Security debt accumulation
<p>Cloud-Native Security Approach:
├── Security policies enable safe development
├── Automated policy validation
├── Security team as platform provider
├── "Security helps you go faster" culture
└── Security by design, not afterthought</p>
<p>Platform Engineering Benefits:
├── Self-service security capabilities
├── Consistent security across teams
├── Reduced time to production
├── Improved compliance posture
└── Better developer experience</code></pre></p>
<h4>Career Development Implications</h4>
<strong>For the Exam:</strong>
<li><strong>RBAC Mastery</strong>: Understand roles, bindings, and permission model</li>
<li><strong>SecurityContext Knowledge</strong>: Configure secure container runtime settings</li>
<li><strong>Network Policy Skills</strong>: Implement micro-segmentation strategies</li>
<li><strong>ServiceAccount Understanding</strong>: Manage pod identity and API access</li>
<strong>For Production Systems:</strong>
<li><strong>Zero Trust Architecture</strong>: Design systems with identity-based security</li>
<li><strong>Compliance Automation</strong>: Implement automated security policy enforcement</li>
<li><strong>Incident Response</strong>: Build observable and auditable security systems</li>
<li><strong>Risk Management</strong>: Balance security requirements with operational needs</li>
<strong>For Your Career:</strong>
<li><strong>Security Leadership</strong>: Guide organizations in adopting secure practices</li>
<li><strong>Platform Engineering</strong>: Build secure, self-service development platforms</li>
<li><strong>Architecture</strong>: Design systems that are secure by default</li>
<li><strong>DevSecOps</strong>: Integrate security into development and operations workflows</li></ul>
<p>Understanding Kubernetes security deeply teaches you how to build <strong>secure, compliant, and auditable</strong> systems that protect against modern threats while enabling developer productivity. This knowledge is fundamental to the CKA exam and essential for anyone operating production Kubernetes environments.</p>
<p>Security in Kubernetes isn't just about preventing attacks - it's about building systems that are resilient, observable, and maintainable while meeting the compliance and governance requirements of modern enterprises.</p>
            </div>
        </div>
        
        <div class="note-footer">
            <p><a href="../index.html">← Back to Alex Susanu's Knowledge Base</a></p>
        </div>
    </div>
</body>
</html>